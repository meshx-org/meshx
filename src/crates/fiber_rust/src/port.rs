// Copyright 2023 MeshX Contributors. All rights reserved.
// Copyright 2017 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! Type-safe bindings for Zircon port objects.

use {
    crate::{impl_handle_based, ok, AsHandleRef, Handle, HandleBased, HandleRef, Signals, Status, Time},
    bitflags::bitflags,
    fiber_sys as sys,
    std::mem,
};

/// A packet sent through a port. This is a type-safe wrapper for
/// [zx_port_packet_t](https://fuchsia.dev/fuchsia-src/reference/syscalls/port_wait.md).
#[derive(PartialEq, Eq, Debug)]
pub struct Packet(sys::fx_port_packet_t);

impl Packet {
    /// Creates a new packet with `UserPacket` data.
    pub fn from_user_packet(key: u64, status: i32, user: UserPacket) -> Packet {
        Packet(sys::fx_port_packet_t {
            key,
            packet_type: sys::fx_packet_type_t::FX_PKT_TYPE_USER,
            status,
            union: user.0,
        })
    }

    /// The packet's key.
    pub fn key(&self) -> u64 {
        self.0.key
    }

    /// The packet's status.
    // TODO: should this type be wrapped?
    pub fn status(&self) -> i32 {
        self.0.status
    }

    /// The contents of the packet.
    pub fn contents(&self) -> PacketContents {
        match self.0.packet_type {
            sys::fx_packet_type_t::FX_PKT_TYPE_USER => PacketContents::User(UserPacket(self.0.union)),
            sys::fx_packet_type_t::FX_PKT_TYPE_SIGNAL_ONE => {
                PacketContents::SignalOne(SignalPacket(unsafe { mem::transmute_copy(&self.0.union) }))
            }
            _ => panic!("unexpected packet type"),
        }
    }
}

/// The contents of a `Packet`.
#[derive(Debug, Copy, Clone)]
pub enum PacketContents {
    /// A user-generated packet.
    User(UserPacket),
    /// A one-shot signal packet generated via `object_wait_async`.
    SignalOne(SignalPacket),

    #[doc(hidden)]
    __Nonexhaustive,
}

/// Contents of a user packet (one sent by `port_queue`). This is a type-safe wrapper for
/// [zx_packet_user_t](https://fuchsia.dev/fuchsia-src/reference/syscalls/port_wait.md).
#[derive(Debug, Copy, Clone)]
pub struct UserPacket(sys::fx_packet_user_t);

/// Contents of a signal packet (one generated by the kernel). This is a type-safe wrapper for
/// [zx_packet_signal_t](https://fuchsia.dev/fuchsia-src/reference/syscalls/port_wait.md).
#[derive(Debug, Copy, Clone)]
pub struct SignalPacket(sys::fx_packet_signal_t);

impl UserPacket {
    pub fn from_u8_array(val: [u8; 32]) -> UserPacket {
        UserPacket(val)
    }

    pub fn as_u8_array(&self) -> &[u8; 32] {
        &self.0
    }

    pub fn as_mut_u8_array(&mut self) -> &mut [u8; 32] {
        &mut self.0
    }
}

impl SignalPacket {
    /// The signals used in the call to `object_wait_async`.
    pub fn trigger(&self) -> Signals {
        Signals::from_bits_truncate(self.0.trigger)
    }

    /// The observed signals.
    pub fn observed(&self) -> Signals {
        Signals::from_bits_truncate(self.0.observed)
    }

    /// A per object count of pending operations.
    pub fn count(&self) -> u64 {
        self.0.count
    }

    /// Get a reference to the raw underlying packet.
    pub fn raw_packet(&self) -> &sys::fx_packet_signal_t {
        &self.0
    }
}

/// An object representing a Fiber
/// [port](https://fuchsia.dev/fuchsia-src/concepts/objects/port.md).
///
/// As essentially a subtype of `Handle`, it can be freely interconverted.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct Port(Handle);
impl_handle_based!(Port);

impl Port {
    /// Create an IO port, allowing IO packets to be read and enqueued.
    ///
    /// Wraps the
    /// [fx_port_create](https://meshx.co/docs/reference/syscalls/port_create.md)
    /// syscall.
    ///
    /// # Panics
    ///
    /// If the kernel reports no memory available to create a port or the process' job policy
    /// denies port creation.
    pub fn create() -> Self {
        unsafe {
            let mut handle = 0;
            let opts = 0;
            let status = sys::fx_port_create(opts, &mut handle);
            ok(status).expect("port creation always succeeds except with OOM or when job policy denies it");
            Handle::from_raw(handle).into()
        }
    }

    /// Attempt to queue a user packet to the IO port.
    ///
    /// Wraps the
    /// [fx_port_queue](https://meshx.co/docs/reference/syscalls/port_queue.md)
    /// syscall.
    pub fn queue(&self, packet: &Packet) -> Result<(), Status> {
        let status = unsafe { sys::fx_port_queue(self.raw_handle(), &packet.0 as *const sys::fx_port_packet_t) };
        ok(status)
    }

    /// Wait for a packet to arrive on a (V2) port.
    ///
    /// Wraps the
    /// [fx_port_wait](https://meshx.co/docs/reference/syscalls/port_wait.md)
    /// syscall.
    pub fn wait(&self, deadline: Time) -> Result<Packet, Status> {
        let mut packet = Default::default();
        ok(unsafe { sys::fx_port_wait(self.raw_handle(), deadline.into_nanos(), &mut packet) })?;
        Ok(Packet(packet))
    }

    /// Cancel pending wait_async calls for an object with the given key.
    ///
    /// Wraps the
    /// [fx_port_cancel](https://meshx.co/docs/reference/syscalls/port_cancel.md)
    /// syscall.
    pub fn cancel<H>(&self, source: &H, key: u64) -> Result<(), Status>
    where
        H: AsHandleRef,
    {
        let status = unsafe { sys::fx_port_cancel(self.raw_handle(), source.raw_handle(), key) };
        ok(status)
    }
}

bitflags! {
    #[repr(transparent)]
    /// Options for wait_async
    pub struct WaitAsyncOpts: u32 {
        /// When set, causes the system to capture a timestamp when the wait triggered.
        const TIMESTAMP = sys::FX_WAIT_ASYNC_TIMESTAMP;
        // When set, causes the port to not enqueue a packet for signals active at
        // the time of the fx_object_wait_async() call.
        const EDGE_TRIGGERED = sys::FX_WAIT_ASYNC_EDGE;
    }
}

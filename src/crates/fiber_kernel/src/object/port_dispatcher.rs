use std::sync::{Arc, Mutex};

use super::{
    BaseDispatcher, Dispatcher, GenericDispatcher, Handle, KernelHandle, SignalObserver, TriggerMode, TypedDispatcher,
};
use fiber_sys as sys;

/// Contents of a signal packet (one generated by the kernel). This is a type-safe wrapper for
/// [fx_packet_signal_t](https://fuchsia.dev/fuchsia-src/reference/syscalls/port_wait.md).
#[derive(Debug, Copy, Clone)]
pub struct SignalPacket(sys::fx_packet_signal_t);

#[derive(Debug)]
struct PortPacket {
    packet: Option<sys::fx_port_packet_t>,
    handle: Arc<Handle>,
}

#[derive(Debug)]
struct PortObserver {
    options: u32,
    packet: PortPacket,

    port: Arc<PortDispatcher>,
    dispatcher: GenericDispatcher,
}

impl PortObserver {
    fn new(
        options: u32,
        handle: Arc<Handle>,
        port: Arc<PortDispatcher>,
        key: u64,
        signals: sys::fx_signals_t,
    ) -> Arc<Self> {
        let dispatcher = handle.dispatcher();

        let mut observer = Self {
            options,
            packet: PortPacket { packet: None, handle },
            port,
            dispatcher,
        };

        let mut packet = sys::fx_port_packet_t {
            status: sys::FX_OK,
            key,
            packet_type: sys::fx_packet_type_t::FX_PKT_TYPE_SIGNAL_ONE,
            union: Default::default(),
        };

        let mut signal_packet = sys::fx_packet_signal_t::default();
        signal_packet.trigger = signals;

        // transmute_copy doesn't work because the io packet is too small and
        // transmute_copy requires that Dst is not larger than Src.
        let bytes: &[u8; std::mem::size_of::<sys::fx_packet_signal_t>()] =
            unsafe { std::mem::transmute(&signal_packet) };
        packet.union[0..std::mem::size_of::<sys::fx_packet_signal_t>()].copy_from_slice(bytes);

        observer.packet.packet = Some(packet);

        Arc::new(observer)
    }

    //fn matches_key(&self, port: *const (), key: u64) -> bool {
    //    return key == self.packet.key() && port == self.port.get();
    //}
}

impl SignalObserver for PortObserver {
    fn on_match(&self, signals: sys::fx_signals_t) {
        todo!()
    }

    fn on_cancel(&self, signals: sys::fx_signals_t) {
        todo!()
    }

    fn get_triggering_signals(&self) -> sys::fx_signals_t {
        todo!()
    }

    fn set_triggeting_signals(&self, signals: sys::fx_signals_t) {
        todo!()
    }

    fn set_handle(&self, handle: Arc<Handle>) {
        todo!()
    }

    fn get_koid(&self) -> sys::fx_koid_t {
        todo!()
    }
}

#[derive(Debug)]
struct GuardedPortState {
    zero_handles: bool,

    // Keeps track of outstanding observers so they can be removed from dispatchers once handle
    // count drops to zero.
    observers: Vec<Arc<PortObserver>>,
}

#[derive(Debug)]
pub(crate) struct PortDispatcher {
    base: BaseDispatcher,
    guarded: Mutex<GuardedPortState>
}

impl Dispatcher for PortDispatcher {
    fn get_koid(&self) -> sys::fx_koid_t {
        self.base.get_koid()
    }

    fn get_related_koid(&self) -> sys::fx_koid_t {
        0
    }

    fn base(&self) -> &super::BaseDispatcher {
        &self.base
    }
}

impl TypedDispatcher for PortDispatcher {
    fn default_rights() -> sys::fx_rights_t {
        sys::FX_DEFAULT_PORT_RIGHTS
    }

    fn get_type() -> sys::fx_obj_type_t {
        sys::FX_OBJ_TYPE_PORT
    }
}

impl PortDispatcher {
    pub fn create() -> (sys::fx_status_t, Option<KernelHandle<PortDispatcher>>, sys::fx_rights_t) {
        let new_handle = KernelHandle::new(super::GenericDispatcher::PortDispatcher(PortDispatcher::new().into()));
        (sys::FX_OK, Some(new_handle), PortDispatcher::default_rights())
    }

    pub fn new() -> Arc<PortDispatcher> {
        Arc::new(PortDispatcher {
            base: BaseDispatcher::new(0),
            guarded: Mutex::new(GuardedPortState {
                zero_handles: false,
                observers: Vec::new(),
            }),
        })
    }

    pub fn make_observer(
        port: Arc<PortDispatcher>,
        options: u32,
        handle: Arc<Handle>,
        key: u64,
        signals: sys::fx_signals_t,
    ) -> sys::fx_status_t {
        // Called under the handle table lock.
        let dispatcher = handle.dispatcher().as_port_dispatcher().unwrap();
        if !dispatcher.is_waitable() {
            return sys::FX_ERR_NOT_SUPPORTED;
        }

        let observer = PortObserver::new(options, handle.clone(), port.clone(), key, signals);

        {
            let mut guard = port.guarded.lock().unwrap();

            debug_assert!(!guard.zero_handles);

            // If we're over the limit, raise an exception.
            if guard.observers.len() >= 1024
            /*gBootOptions.max_port_observers*/
            {
                // We limit the number of observers to prevent a misbehaving program from impacting system
                // performance or stability.
                // TODO: Thread::Current::SignalPolicyException(sys::FX_EXCP_POLICY_CODE_PORT_TOO_MANY_OBSERVERS, 0u);
                panic!("Thread::Current::SignalPolicyException should not return");
            }

            guard.observers.insert(0, observer.clone());
        }

        let trigger_mode = TriggerMode::Level;

        // TODO: bitflags
        //let trigger_mode = if options & sys::FX_WAIT_ASYNC_EDGE {
        //    TriggerMode::Edge
        //} else {
        //    TriggerMode::Level
        //};

        dispatcher.add_observer(observer, handle, signals, trigger_mode)
    }
}

/* eslint-disable @typescript-eslint/no-inferrable-types */
// WARNING: This file is machine generated by midlgen.

import * as midl from ".."
import * as fiber from "@meshx-org/fiber-ts"
// WARNING: This file is machine generated by midlgen.

/* eslint-disable @typescript-eslint/no-inferrable-types */

import * as midl from "@meshx-org/midl"
import * as fiber from "@meshx-org/fiber-ts"

export class ErrorEnum extends midl.Enum {
    public static readonly ErrFoo = new ErrorEnum(1, false)
    public static readonly ErrBar = new ErrorEnum(2, false)
    public static readonly $unknown = new ErrorEnum(0xffffffff, true)

    readonly #isUnknown: boolean
    static readonly #values = new Map<number, ErrorEnum>([
        [1, ErrorEnum.ErrFoo],
        [2, ErrorEnum.ErrBar],
    ])

    public readonly value: number
    public static readonly values: ErrorEnum[] = [ErrorEnum.ErrFoo, ErrorEnum.ErrBar]
    public static readonly valuesMap: Record<string, ErrorEnum> = {
        ErrFoo: ErrorEnum.ErrFoo,
        ErrBar: ErrorEnum.ErrBar,
    }

    private constructor(value: number, isUnknown: boolean) {
        super()
        this.value = value
        this.#isUnknown = isUnknown
    }

    public static override valueOf(name: string): ErrorEnum | undefined {
        return this.valuesMap[name]
    }

    public isUnknown(): boolean {
        return this.#isUnknown
    }

    public static create(value: number): ErrorEnum {
        if (!this.#values.has(value)) {
            this.#values.set(value, new ErrorEnum(value, true))
        }
        return this.#values.get(value)!
    }
}

export const _ErrorEnumType = new midl.EnumType<ErrorEnum>(new midl.UInt32Type())

enum TheUnionTag {
    $unknown,
    V = 1,
}

const _TheUnion_map: Map<number, TheUnionTag> = new Map<number, TheUnionTag>([[1, TheUnionTag.V]])

export class TheUnion extends midl.Union {
    #ordinal: number
    #data: any

    constructor(ordinal: number, data: any) {
        super()
        this.#ordinal = ordinal
        this.#data = data
    }

    static withV(value: number): TheUnion {
        return new TheUnion(1, value)
    }

    static with$UnknownData(ordinal: number, data: midl.UnknownRawData): TheUnion {
        return new TheUnion(ordinal, data)
    }

    get $tag(): TheUnionTag {
        return _TheUnion_map.get(this.#ordinal) ?? TheUnionTag.$unknown
    }

    get V(): number | null {
        if (this.#ordinal !== 1) return null
        return this.#data as number
    }

    get $unknownData(): midl.UnknownRawData | null {
        if (this.#ordinal === 1) {
            return null
        }
        return this.#data as midl.UnknownRawData
    }

    override get $ordinal(): number {
        return this.#ordinal
    }

    override get $data(): unknown {
        return this.#data
    }

    public override valueOf() {
        return this.#data
    }

    static ctor(ordinal: number, data: object): TheUnion {
        return new TheUnion(ordinal, data)
    }
}

const _TheUnionType = new midl.UnionType<TheUnion>(
    {
        1: new midl.UInt32Type(),
    },
    TheUnion.ctor,
    false,
    false
)

enum WithErrorSyntaxErrorAsEnumResultTag {
    $unknown,
    Response = 1,
    Err = 2,
}

const _WithErrorSyntaxErrorAsEnumResult_map: Map<number, WithErrorSyntaxErrorAsEnumResultTag> = new Map<
    number,
    WithErrorSyntaxErrorAsEnumResultTag
>([
    [1, WithErrorSyntaxErrorAsEnumResultTag.Response],
    [2, WithErrorSyntaxErrorAsEnumResultTag.Err],
])

export class WithErrorSyntaxErrorAsEnumResult extends midl.Union {
    #ordinal: number
    #data: any

    constructor(ordinal: number, data: any) {
        super()
        this.#ordinal = ordinal
        this.#data = data
    }

    static withResponse(value: number): WithErrorSyntaxErrorAsEnumResult {
        return new WithErrorSyntaxErrorAsEnumResult(1, value)
    }

    static withErr(value: number): WithErrorSyntaxErrorAsEnumResult {
        return new WithErrorSyntaxErrorAsEnumResult(2, value)
    }

    static with$UnknownData(ordinal: number, data: midl.UnknownRawData): WithErrorSyntaxErrorAsEnumResult {
        return new WithErrorSyntaxErrorAsEnumResult(ordinal, data)
    }

    get $tag(): WithErrorSyntaxErrorAsEnumResultTag {
        return _WithErrorSyntaxErrorAsEnumResult_map.get(this.#ordinal) ?? WithErrorSyntaxErrorAsEnumResultTag.$unknown
    }

    get Response(): number | null {
        if (this.#ordinal !== 1) return null
        return this.#data as number
    }

    get Err(): number | null {
        if (this.#ordinal !== 2) return null
        return this.#data as number
    }

    get $unknownData(): midl.UnknownRawData | null {
        if (this.#ordinal === 1) {
            return null
        }
        return this.#data as midl.UnknownRawData
    }

    override get $ordinal(): number {
        return this.#ordinal
    }

    override get $data(): unknown {
        return this.#data
    }

    public override valueOf() {
        return this.#data
    }

    static ctor(ordinal: number, data: object): WithErrorSyntaxErrorAsEnumResult {
        return new WithErrorSyntaxErrorAsEnumResult(ordinal, data)
    }
}

const _WithErrorSyntaxErrorAsEnumResultType = new midl.UnionType<WithErrorSyntaxErrorAsEnumResult>(
    {
        1: _WithErrorSyntaxErrorAsEnumResponseType,
        2: _ErrorEnumType,
    },
    WithErrorSyntaxErrorAsEnumResult.ctor,
    true,
    false
)

enum WithErrorSyntaxErrorAsPrimitiveResultTag {
    $unknown,
    Response = 1,
    Err = 2,
}

const _WithErrorSyntaxErrorAsPrimitiveResult_map: Map<number, WithErrorSyntaxErrorAsPrimitiveResultTag> = new Map<
    number,
    WithErrorSyntaxErrorAsPrimitiveResultTag
>([
    [1, WithErrorSyntaxErrorAsPrimitiveResultTag.Response],
    [2, WithErrorSyntaxErrorAsPrimitiveResultTag.Err],
])

export class WithErrorSyntaxErrorAsPrimitiveResult extends midl.Union {
    #ordinal: number
    #data: any

    constructor(ordinal: number, data: any) {
        super()
        this.#ordinal = ordinal
        this.#data = data
    }

    static withResponse(value: number): WithErrorSyntaxErrorAsPrimitiveResult {
        return new WithErrorSyntaxErrorAsPrimitiveResult(1, value)
    }

    static withErr(value: number): WithErrorSyntaxErrorAsPrimitiveResult {
        return new WithErrorSyntaxErrorAsPrimitiveResult(2, value)
    }

    static with$UnknownData(ordinal: number, data: midl.UnknownRawData): WithErrorSyntaxErrorAsPrimitiveResult {
        return new WithErrorSyntaxErrorAsPrimitiveResult(ordinal, data)
    }

    get $tag(): WithErrorSyntaxErrorAsPrimitiveResultTag {
        return (
            _WithErrorSyntaxErrorAsPrimitiveResult_map.get(this.#ordinal) ??
            WithErrorSyntaxErrorAsPrimitiveResultTag.$unknown
        )
    }

    get Response(): number | null {
        if (this.#ordinal !== 1) return null
        return this.#data as number
    }

    get Err(): number | null {
        if (this.#ordinal !== 2) return null
        return this.#data as number
    }

    get $unknownData(): midl.UnknownRawData | null {
        if (this.#ordinal === 1) {
            return null
        }
        return this.#data as midl.UnknownRawData
    }

    override get $ordinal(): number {
        return this.#ordinal
    }

    override get $data(): unknown {
        return this.#data
    }

    public override valueOf() {
        return this.#data
    }

    static ctor(ordinal: number, data: object): WithErrorSyntaxErrorAsPrimitiveResult {
        return new WithErrorSyntaxErrorAsPrimitiveResult(ordinal, data)
    }
}

const _WithErrorSyntaxErrorAsPrimitiveResultType = new midl.UnionType<WithErrorSyntaxErrorAsPrimitiveResult>(
    {
        1: _WithErrorSyntaxErrorAsPrimitiveResponseType,
        2: new midl.UInt32Type(),
    },
    WithErrorSyntaxErrorAsPrimitiveResult.ctor,
    true,
    false
)

enum WithErrorSyntaxHandleInResultResultTag {
    $unknown,
    Response = 1,
    Err = 2,
}

const _WithErrorSyntaxHandleInResultResult_map: Map<number, WithErrorSyntaxHandleInResultResultTag> = new Map<
    number,
    WithErrorSyntaxHandleInResultResultTag
>([
    [1, WithErrorSyntaxHandleInResultResultTag.Response],
    [2, WithErrorSyntaxHandleInResultResultTag.Err],
])

export class WithErrorSyntaxHandleInResultResult extends midl.Union {
    #ordinal: number
    #data: any

    constructor(ordinal: number, data: any) {
        super()
        this.#ordinal = ordinal
        this.#data = data
    }

    static withResponse(value: number): WithErrorSyntaxHandleInResultResult {
        return new WithErrorSyntaxHandleInResultResult(1, value)
    }

    static withErr(value: number): WithErrorSyntaxHandleInResultResult {
        return new WithErrorSyntaxHandleInResultResult(2, value)
    }

    static with$UnknownData(ordinal: number, data: midl.UnknownRawData): WithErrorSyntaxHandleInResultResult {
        return new WithErrorSyntaxHandleInResultResult(ordinal, data)
    }

    get $tag(): WithErrorSyntaxHandleInResultResultTag {
        return (
            _WithErrorSyntaxHandleInResultResult_map.get(this.#ordinal) ??
            WithErrorSyntaxHandleInResultResultTag.$unknown
        )
    }

    get Response(): number | null {
        if (this.#ordinal !== 1) return null
        return this.#data as number
    }

    get Err(): number | null {
        if (this.#ordinal !== 2) return null
        return this.#data as number
    }

    get $unknownData(): midl.UnknownRawData | null {
        if (this.#ordinal === 1) {
            return null
        }
        return this.#data as midl.UnknownRawData
    }

    override get $ordinal(): number {
        return this.#ordinal
    }

    override get $data(): unknown {
        return this.#data
    }

    public override valueOf() {
        return this.#data
    }

    static ctor(ordinal: number, data: object): WithErrorSyntaxHandleInResultResult {
        return new WithErrorSyntaxHandleInResultResult(ordinal, data)
    }
}

const _WithErrorSyntaxHandleInResultResultType = new midl.UnionType<WithErrorSyntaxHandleInResultResult>(
    {
        1: _WithErrorSyntaxHandleInResultResponseType,
        2: new midl.UInt32Type(),
    },
    WithErrorSyntaxHandleInResultResult.ctor,
    true,
    false
)

enum WithErrorSyntaxResponseAsStructResultTag {
    $unknown,
    Response = 1,
    Err = 2,
}

const _WithErrorSyntaxResponseAsStructResult_map: Map<number, WithErrorSyntaxResponseAsStructResultTag> = new Map<
    number,
    WithErrorSyntaxResponseAsStructResultTag
>([
    [1, WithErrorSyntaxResponseAsStructResultTag.Response],
    [2, WithErrorSyntaxResponseAsStructResultTag.Err],
])

export class WithErrorSyntaxResponseAsStructResult extends midl.Union {
    #ordinal: number
    #data: any

    constructor(ordinal: number, data: any) {
        super()
        this.#ordinal = ordinal
        this.#data = data
    }

    static withResponse(value: number): WithErrorSyntaxResponseAsStructResult {
        return new WithErrorSyntaxResponseAsStructResult(1, value)
    }

    static withErr(value: number): WithErrorSyntaxResponseAsStructResult {
        return new WithErrorSyntaxResponseAsStructResult(2, value)
    }

    static with$UnknownData(ordinal: number, data: midl.UnknownRawData): WithErrorSyntaxResponseAsStructResult {
        return new WithErrorSyntaxResponseAsStructResult(ordinal, data)
    }

    get $tag(): WithErrorSyntaxResponseAsStructResultTag {
        return (
            _WithErrorSyntaxResponseAsStructResult_map.get(this.#ordinal) ??
            WithErrorSyntaxResponseAsStructResultTag.$unknown
        )
    }

    get Response(): number | null {
        if (this.#ordinal !== 1) return null
        return this.#data as number
    }

    get Err(): number | null {
        if (this.#ordinal !== 2) return null
        return this.#data as number
    }

    get $unknownData(): midl.UnknownRawData | null {
        if (this.#ordinal === 1) {
            return null
        }
        return this.#data as midl.UnknownRawData
    }

    override get $ordinal(): number {
        return this.#ordinal
    }

    override get $data(): unknown {
        return this.#data
    }

    public override valueOf() {
        return this.#data
    }

    static ctor(ordinal: number, data: object): WithErrorSyntaxResponseAsStructResult {
        return new WithErrorSyntaxResponseAsStructResult(ordinal, data)
    }
}

const _WithErrorSyntaxResponseAsStructResultType = new midl.UnionType<WithErrorSyntaxResponseAsStructResult>(
    {
        1: _WithErrorSyntaxResponseAsStructResponseType,
        2: new midl.UInt32Type(),
    },
    WithErrorSyntaxResponseAsStructResult.ctor,
    true,
    false
)

export class ChannelProtocolEventARequest implements midl.Struct {
    static #fieldType0: midl.Int64Type = new midl.Int64Type()
    static #fieldType1: midl.Int64Type = new midl.Int64Type()

    constructor(public a: bigint, public b: bigint) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        ChannelProtocolEventARequest.#fieldType0.encode(encoder, this.a, offset + 0, depth)
        ChannelProtocolEventARequest.#fieldType1.encode(encoder, this.b, offset + 8, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new ChannelProtocolEventARequest(
            ChannelProtocolEventARequest.#fieldType0.decode(decoder, offset + 0, depth),
            ChannelProtocolEventARequest.#fieldType1.decode(decoder, offset + 8, depth)
        )
    }
}

export const _ChannelProtocolEventARequestType = new midl.StructType<ChannelProtocolEventARequest>(
    16,
    ChannelProtocolEventARequest.$decode
)

export class ChannelProtocolMethodARequest implements midl.Struct {
    static #fieldType0: midl.Int64Type = new midl.Int64Type()
    static #fieldType1: midl.Int64Type = new midl.Int64Type()

    constructor(public a: bigint, public b: bigint) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        ChannelProtocolMethodARequest.#fieldType0.encode(encoder, this.a, offset + 0, depth)
        ChannelProtocolMethodARequest.#fieldType1.encode(encoder, this.b, offset + 8, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new ChannelProtocolMethodARequest(
            ChannelProtocolMethodARequest.#fieldType0.decode(decoder, offset + 0, depth),
            ChannelProtocolMethodARequest.#fieldType1.decode(decoder, offset + 8, depth)
        )
    }
}

export const _ChannelProtocolMethodARequestType = new midl.StructType<ChannelProtocolMethodARequest>(
    16,
    ChannelProtocolMethodARequest.$decode
)

export class ChannelProtocolMethodBRequest implements midl.Struct {
    static #fieldType0: midl.Int64Type = new midl.Int64Type()
    static #fieldType1: midl.Int64Type = new midl.Int64Type()

    constructor(public a: bigint, public b: bigint) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        ChannelProtocolMethodBRequest.#fieldType0.encode(encoder, this.a, offset + 0, depth)
        ChannelProtocolMethodBRequest.#fieldType1.encode(encoder, this.b, offset + 8, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new ChannelProtocolMethodBRequest(
            ChannelProtocolMethodBRequest.#fieldType0.decode(decoder, offset + 0, depth),
            ChannelProtocolMethodBRequest.#fieldType1.decode(decoder, offset + 8, depth)
        )
    }
}

export const _ChannelProtocolMethodBRequestType = new midl.StructType<ChannelProtocolMethodBRequest>(
    16,
    ChannelProtocolMethodBRequest.$decode
)

export class ChannelProtocolMethodBResponse implements midl.Struct {
    static #fieldType0: midl.Int64Type = new midl.Int64Type()

    constructor(public result: bigint) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        ChannelProtocolMethodBResponse.#fieldType0.encode(encoder, this.result, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new ChannelProtocolMethodBResponse(
            ChannelProtocolMethodBResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _ChannelProtocolMethodBResponseType = new midl.StructType<ChannelProtocolMethodBResponse>(
    8,
    ChannelProtocolMethodBResponse.$decode
)

export class ChannelProtocolMutateSocketRequest implements midl.Struct {
    static #fieldType0: midl.HandleType = new midl.HandleType(midl.ObjectType.SOCKET, 2147483648)

    constructor(public a: midl.Socket) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        ChannelProtocolMutateSocketRequest.#fieldType0.encode(encoder, this.a, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new ChannelProtocolMutateSocketRequest(
            ChannelProtocolMutateSocketRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _ChannelProtocolMutateSocketRequestType = new midl.StructType<ChannelProtocolMutateSocketRequest>(
    4,
    ChannelProtocolMutateSocketRequest.$decode
)

export class ChannelProtocolMutateSocketResponse implements midl.Struct {
    static #fieldType0: midl.HandleType = new midl.HandleType(midl.ObjectType.SOCKET, 2147483648)

    constructor(public b: midl.Socket) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        ChannelProtocolMutateSocketResponse.#fieldType0.encode(encoder, this.b, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new ChannelProtocolMutateSocketResponse(
            ChannelProtocolMutateSocketResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _ChannelProtocolMutateSocketResponseType = new midl.StructType<ChannelProtocolMutateSocketResponse>(
    4,
    ChannelProtocolMutateSocketResponse.$decode
)

export class ChannelProtocolTakeHandleRequest implements midl.Struct {
    static #fieldType0: midl.HandleType = new midl.HandleType(FX_OBJECT_TYPE_NONE, 2147483648)

    constructor(public h: midl.Handle) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        ChannelProtocolTakeHandleRequest.#fieldType0.encode(encoder, this.h, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new ChannelProtocolTakeHandleRequest(
            ChannelProtocolTakeHandleRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _ChannelProtocolTakeHandleRequestType = new midl.StructType<ChannelProtocolTakeHandleRequest>(
    4,
    ChannelProtocolTakeHandleRequest.$decode
)

export class HandleRightsProtocolAnEventRequest implements midl.Struct {
    static #fieldType0: midl.HandleType = new midl.HandleType(midl.ObjectType.SOCKET, 3)

    constructor(public h: midl.Socket) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        HandleRightsProtocolAnEventRequest.#fieldType0.encode(encoder, this.h, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new HandleRightsProtocolAnEventRequest(
            HandleRightsProtocolAnEventRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _HandleRightsProtocolAnEventRequestType = new midl.StructType<HandleRightsProtocolAnEventRequest>(
    4,
    HandleRightsProtocolAnEventRequest.$decode
)

export class HandleRightsProtocolNoResponseMethodRequest implements midl.Struct {
    static #fieldType0: midl.HandleType = new midl.HandleType(midl.ObjectType.SOCKET, 3)

    constructor(public h: midl.Socket) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        HandleRightsProtocolNoResponseMethodRequest.#fieldType0.encode(encoder, this.h, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new HandleRightsProtocolNoResponseMethodRequest(
            HandleRightsProtocolNoResponseMethodRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _HandleRightsProtocolNoResponseMethodRequestType =
    new midl.StructType<HandleRightsProtocolNoResponseMethodRequest>(
        4,
        HandleRightsProtocolNoResponseMethodRequest.$decode
    )

export class HandleRightsProtocolResponseMethodRequest implements midl.Struct {
    static #fieldType0: midl.HandleType = new midl.HandleType(midl.ObjectType.SOCKET, 3)

    constructor(public h: midl.Socket) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        HandleRightsProtocolResponseMethodRequest.#fieldType0.encode(encoder, this.h, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new HandleRightsProtocolResponseMethodRequest(
            HandleRightsProtocolResponseMethodRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _HandleRightsProtocolResponseMethodRequestType =
    new midl.StructType<HandleRightsProtocolResponseMethodRequest>(4, HandleRightsProtocolResponseMethodRequest.$decode)

export class HandleRightsProtocolResponseMethodResponse implements midl.Struct {
    static #fieldType0: midl.HandleType = new midl.HandleType(midl.ObjectType.SOCKET, 2)

    constructor(public h: midl.Socket) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        HandleRightsProtocolResponseMethodResponse.#fieldType0.encode(encoder, this.h, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new HandleRightsProtocolResponseMethodResponse(
            HandleRightsProtocolResponseMethodResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _HandleRightsProtocolResponseMethodResponseType =
    new midl.StructType<HandleRightsProtocolResponseMethodResponse>(
        4,
        HandleRightsProtocolResponseMethodResponse.$decode
    )

export class ManyParametersFifteenRequest implements midl.Struct {
    static #fieldType0: midl.BoolType = new midl.BoolType()
    static #fieldType1: midl.BoolType = new midl.BoolType()
    static #fieldType2: midl.BoolType = new midl.BoolType()
    static #fieldType3: midl.BoolType = new midl.BoolType()
    static #fieldType4: midl.BoolType = new midl.BoolType()
    static #fieldType5: midl.BoolType = new midl.BoolType()
    static #fieldType6: midl.BoolType = new midl.BoolType()
    static #fieldType7: midl.BoolType = new midl.BoolType()
    static #fieldType8: midl.BoolType = new midl.BoolType()
    static #fieldType9: midl.BoolType = new midl.BoolType()
    static #fieldType10: midl.BoolType = new midl.BoolType()
    static #fieldType11: midl.BoolType = new midl.BoolType()
    static #fieldType12: midl.BoolType = new midl.BoolType()
    static #fieldType13: midl.BoolType = new midl.BoolType()
    static #fieldType14: midl.BoolType = new midl.BoolType()

    constructor(
        public p_1: boolean,
        public p_2: boolean,
        public p_3: boolean,
        public p_4: boolean,
        public p_5: boolean,
        public p_6: boolean,
        public p_7: boolean,
        public p_8: boolean,
        public p_9: boolean,
        public p_10: boolean,
        public p_11: boolean,
        public p_12: boolean,
        public p_13: boolean,
        public p_14: boolean,
        public p_15: boolean
    ) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        ManyParametersFifteenRequest.#fieldType0.encode(encoder, this.p_1, offset + 0, depth)
        ManyParametersFifteenRequest.#fieldType1.encode(encoder, this.p_2, offset + 1, depth)
        ManyParametersFifteenRequest.#fieldType2.encode(encoder, this.p_3, offset + 2, depth)
        ManyParametersFifteenRequest.#fieldType3.encode(encoder, this.p_4, offset + 3, depth)
        ManyParametersFifteenRequest.#fieldType4.encode(encoder, this.p_5, offset + 4, depth)
        ManyParametersFifteenRequest.#fieldType5.encode(encoder, this.p_6, offset + 5, depth)
        ManyParametersFifteenRequest.#fieldType6.encode(encoder, this.p_7, offset + 6, depth)
        ManyParametersFifteenRequest.#fieldType7.encode(encoder, this.p_8, offset + 7, depth)
        ManyParametersFifteenRequest.#fieldType8.encode(encoder, this.p_9, offset + 8, depth)
        ManyParametersFifteenRequest.#fieldType9.encode(encoder, this.p_10, offset + 9, depth)
        ManyParametersFifteenRequest.#fieldType10.encode(encoder, this.p_11, offset + 10, depth)
        ManyParametersFifteenRequest.#fieldType11.encode(encoder, this.p_12, offset + 11, depth)
        ManyParametersFifteenRequest.#fieldType12.encode(encoder, this.p_13, offset + 12, depth)
        ManyParametersFifteenRequest.#fieldType13.encode(encoder, this.p_14, offset + 13, depth)
        ManyParametersFifteenRequest.#fieldType14.encode(encoder, this.p_15, offset + 14, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new ManyParametersFifteenRequest(
            ManyParametersFifteenRequest.#fieldType0.decode(decoder, offset + 0, depth),
            ManyParametersFifteenRequest.#fieldType1.decode(decoder, offset + 1, depth),
            ManyParametersFifteenRequest.#fieldType2.decode(decoder, offset + 2, depth),
            ManyParametersFifteenRequest.#fieldType3.decode(decoder, offset + 3, depth),
            ManyParametersFifteenRequest.#fieldType4.decode(decoder, offset + 4, depth),
            ManyParametersFifteenRequest.#fieldType5.decode(decoder, offset + 5, depth),
            ManyParametersFifteenRequest.#fieldType6.decode(decoder, offset + 6, depth),
            ManyParametersFifteenRequest.#fieldType7.decode(decoder, offset + 7, depth),
            ManyParametersFifteenRequest.#fieldType8.decode(decoder, offset + 8, depth),
            ManyParametersFifteenRequest.#fieldType9.decode(decoder, offset + 9, depth),
            ManyParametersFifteenRequest.#fieldType10.decode(decoder, offset + 10, depth),
            ManyParametersFifteenRequest.#fieldType11.decode(decoder, offset + 11, depth),
            ManyParametersFifteenRequest.#fieldType12.decode(decoder, offset + 12, depth),
            ManyParametersFifteenRequest.#fieldType13.decode(decoder, offset + 13, depth),
            ManyParametersFifteenRequest.#fieldType14.decode(decoder, offset + 14, depth)
        )
    }
}

export const _ManyParametersFifteenRequestType = new midl.StructType<ManyParametersFifteenRequest>(
    15,
    ManyParametersFifteenRequest.$decode
)

export class MethodWithUnionUnionMethodRequest implements midl.Struct {
    static #fieldType0: midl.UnionType<TheUnion> = _TheUnionType

    constructor(public u: TheUnion) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        MethodWithUnionUnionMethodRequest.#fieldType0.encode(encoder, this.u, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new MethodWithUnionUnionMethodRequest(
            MethodWithUnionUnionMethodRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _MethodWithUnionUnionMethodRequestType = new midl.StructType<MethodWithUnionUnionMethodRequest>(
    16,
    MethodWithUnionUnionMethodRequest.$decode
)

export class MethodWithUnionUnionMethodResponse implements midl.Struct {
    static #fieldType0: midl.UnionType<TheUnion> = _TheUnionType

    constructor(public u: TheUnion) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        MethodWithUnionUnionMethodResponse.#fieldType0.encode(encoder, this.u, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new MethodWithUnionUnionMethodResponse(
            MethodWithUnionUnionMethodResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _MethodWithUnionUnionMethodResponseType = new midl.StructType<MethodWithUnionUnionMethodResponse>(
    16,
    MethodWithUnionUnionMethodResponse.$decode
)

export class ProtocolEnds implements midl.Struct {
    static #fieldType0: midl.Endpoint<midl.ClientEnd<DiscoverableProtocolMarker>> = new midl.Endpoint<
        midl.ClientEnd<DiscoverableProtocolMarker>
    >()
    static #fieldType1: midl.InterfaceRequestType<DiscoverableProtocolMarker> =
        new midl.InterfaceRequestType<DiscoverableProtocolMarker>()
    static #fieldType2: midl.OptionalType<midl.Endpoint<midl.ClientEnd<DiscoverableProtocolMarker>>> =
        new midl.OptionalType<midl.Endpoint<midl.ClientEnd<DiscoverableProtocolMarker>>>(
            new midl.Endpoint<midl.ClientEnd<DiscoverableProtocolMarker>>()
        )
    static #fieldType3: midl.NullableInterfaceRequestType<DiscoverableProtocolMarker> =
        new midl.NullableInterfaceRequestType<DiscoverableProtocolMarker>()

    constructor(
        public client: midl.ClientEnd<DiscoverableProtocolMarker>,
        public server: DiscoverableProtocolMarker,
        public client_opt: Option<midl.ClientEnd<DiscoverableProtocolMarker>>,
        public server_opt: DiscoverableProtocolMarker | null
    ) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        ProtocolEnds.#fieldType0.encode(encoder, this.client, offset + 0, depth)
        ProtocolEnds.#fieldType1.encode(encoder, this.server, offset + 4, depth)
        ProtocolEnds.#fieldType2.encode(encoder, this.client_opt, offset + 8, depth)
        ProtocolEnds.#fieldType3.encode(encoder, this.server_opt, offset + 12, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new ProtocolEnds(
            ProtocolEnds.#fieldType0.decode(decoder, offset + 0, depth),
            ProtocolEnds.#fieldType1.decode(decoder, offset + 4, depth),
            ProtocolEnds.#fieldType2.decode(decoder, offset + 8, depth),
            ProtocolEnds.#fieldType3.decode(decoder, offset + 12, depth)
        )
    }
}

export const _ProtocolEndsType = new midl.StructType<ProtocolEnds>(16, ProtocolEnds.$decode)

export class SyscallProtocolMethodCRequest implements midl.Struct {
    static #fieldType0: midl.Int64Type = new midl.Int64Type()
    static #fieldType1: midl.Int64Type = new midl.Int64Type()

    constructor(public a: bigint, public b: bigint) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        SyscallProtocolMethodCRequest.#fieldType0.encode(encoder, this.a, offset + 0, depth)
        SyscallProtocolMethodCRequest.#fieldType1.encode(encoder, this.b, offset + 8, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new SyscallProtocolMethodCRequest(
            SyscallProtocolMethodCRequest.#fieldType0.decode(decoder, offset + 0, depth),
            SyscallProtocolMethodCRequest.#fieldType1.decode(decoder, offset + 8, depth)
        )
    }
}

export const _SyscallProtocolMethodCRequestType = new midl.StructType<SyscallProtocolMethodCRequest>(
    16,
    SyscallProtocolMethodCRequest.$decode
)

export class WithAndWithoutRequestResponseNoRequestWithResponseResponse implements midl.Struct {
    static #fieldType0: midl.StringType = new midl.StringType()

    constructor(public ret: string) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithAndWithoutRequestResponseNoRequestWithResponseResponse.#fieldType0.encode(
            encoder,
            this.ret,
            offset + 0,
            depth
        )
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithAndWithoutRequestResponseNoRequestWithResponseResponse(
            WithAndWithoutRequestResponseNoRequestWithResponseResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithAndWithoutRequestResponseNoRequestWithResponseResponseType =
    new midl.StructType<WithAndWithoutRequestResponseNoRequestWithResponseResponse>(
        16,
        WithAndWithoutRequestResponseNoRequestWithResponseResponse.$decode
    )

export class WithAndWithoutRequestResponseOnWithResponseRequest implements midl.Struct {
    static #fieldType0: midl.StringType = new midl.StringType()

    constructor(public ret: string) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithAndWithoutRequestResponseOnWithResponseRequest.#fieldType0.encode(encoder, this.ret, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithAndWithoutRequestResponseOnWithResponseRequest(
            WithAndWithoutRequestResponseOnWithResponseRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithAndWithoutRequestResponseOnWithResponseRequestType =
    new midl.StructType<WithAndWithoutRequestResponseOnWithResponseRequest>(
        16,
        WithAndWithoutRequestResponseOnWithResponseRequest.$decode
    )

export class WithAndWithoutRequestResponseWithRequestEmptyResponseRequest implements midl.Struct {
    static #fieldType0: midl.StringType = new midl.StringType()

    constructor(public arg: string) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest.#fieldType0.encode(
            encoder,
            this.arg,
            offset + 0,
            depth
        )
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithAndWithoutRequestResponseWithRequestEmptyResponseRequestType =
    new midl.StructType<WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>(
        16,
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest.$decode
    )

export class WithAndWithoutRequestResponseWithRequestNoResponseRequest implements midl.Struct {
    static #fieldType0: midl.StringType = new midl.StringType()

    constructor(public arg: string) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithAndWithoutRequestResponseWithRequestNoResponseRequest.#fieldType0.encode(
            encoder,
            this.arg,
            offset + 0,
            depth
        )
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithAndWithoutRequestResponseWithRequestNoResponseRequest(
            WithAndWithoutRequestResponseWithRequestNoResponseRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithAndWithoutRequestResponseWithRequestNoResponseRequestType =
    new midl.StructType<WithAndWithoutRequestResponseWithRequestNoResponseRequest>(
        16,
        WithAndWithoutRequestResponseWithRequestNoResponseRequest.$decode
    )

export class WithAndWithoutRequestResponseWithRequestWithResponseRequest implements midl.Struct {
    static #fieldType0: midl.StringType = new midl.StringType()

    constructor(public arg: string) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithAndWithoutRequestResponseWithRequestWithResponseRequest.#fieldType0.encode(
            encoder,
            this.arg,
            offset + 0,
            depth
        )
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithAndWithoutRequestResponseWithRequestWithResponseRequest(
            WithAndWithoutRequestResponseWithRequestWithResponseRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithAndWithoutRequestResponseWithRequestWithResponseRequestType =
    new midl.StructType<WithAndWithoutRequestResponseWithRequestWithResponseRequest>(
        16,
        WithAndWithoutRequestResponseWithRequestWithResponseRequest.$decode
    )

export class WithAndWithoutRequestResponseWithRequestWithResponseResponse implements midl.Struct {
    static #fieldType0: midl.StringType = new midl.StringType()

    constructor(public ret: string) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithAndWithoutRequestResponseWithRequestWithResponseResponse.#fieldType0.encode(
            encoder,
            this.ret,
            offset + 0,
            depth
        )
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithAndWithoutRequestResponseWithRequestWithResponseResponse(
            WithAndWithoutRequestResponseWithRequestWithResponseResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithAndWithoutRequestResponseWithRequestWithResponseResponseType =
    new midl.StructType<WithAndWithoutRequestResponseWithRequestWithResponseResponse>(
        16,
        WithAndWithoutRequestResponseWithRequestWithResponseResponse.$decode
    )

export class WithErrorSyntaxErrorAsEnumResponse implements midl.Struct {
    constructor() {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {}

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithErrorSyntaxErrorAsEnumResponse()
    }
}

export const _WithErrorSyntaxErrorAsEnumResponseType = new midl.StructType<WithErrorSyntaxErrorAsEnumResponse>(
    1,
    WithErrorSyntaxErrorAsEnumResponse.$decode
)

export class WithErrorSyntaxErrorAsPrimitiveResponse implements midl.Struct {
    constructor() {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {}

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithErrorSyntaxErrorAsPrimitiveResponse()
    }
}

export const _WithErrorSyntaxErrorAsPrimitiveResponseType =
    new midl.StructType<WithErrorSyntaxErrorAsPrimitiveResponse>(1, WithErrorSyntaxErrorAsPrimitiveResponse.$decode)

export class WithErrorSyntaxHandleInResultResponse implements midl.Struct {
    static #fieldType0: midl.HandleType = new midl.HandleType(FX_OBJECT_TYPE_NONE, 2147483648)

    constructor(public h: midl.Handle) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithErrorSyntaxHandleInResultResponse.#fieldType0.encode(encoder, this.h, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithErrorSyntaxHandleInResultResponse(
            WithErrorSyntaxHandleInResultResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithErrorSyntaxHandleInResultResponseType = new midl.StructType<WithErrorSyntaxHandleInResultResponse>(
    4,
    WithErrorSyntaxHandleInResultResponse.$decode
)

export class WithErrorSyntaxResponseAsStructResponse implements midl.Struct {
    static #fieldType0: midl.Int64Type = new midl.Int64Type()
    static #fieldType1: midl.Int64Type = new midl.Int64Type()
    static #fieldType2: midl.Int64Type = new midl.Int64Type()

    constructor(public a: bigint, public b: bigint, public c: bigint) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithErrorSyntaxResponseAsStructResponse.#fieldType0.encode(encoder, this.a, offset + 0, depth)
        WithErrorSyntaxResponseAsStructResponse.#fieldType1.encode(encoder, this.b, offset + 8, depth)
        WithErrorSyntaxResponseAsStructResponse.#fieldType2.encode(encoder, this.c, offset + 16, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithErrorSyntaxResponseAsStructResponse(
            WithErrorSyntaxResponseAsStructResponse.#fieldType0.decode(decoder, offset + 0, depth),
            WithErrorSyntaxResponseAsStructResponse.#fieldType1.decode(decoder, offset + 8, depth),
            WithErrorSyntaxResponseAsStructResponse.#fieldType2.decode(decoder, offset + 16, depth)
        )
    }
}

export const _WithErrorSyntaxResponseAsStructResponseType =
    new midl.StructType<WithErrorSyntaxResponseAsStructResponse>(24, WithErrorSyntaxResponseAsStructResponse.$decode)

export class WithProtocolEndsClientEndsRequest implements midl.Struct {
    static #fieldType0: midl.Endpoint<midl.ClientEnd<DiscoverableProtocolMarker>> = new midl.Endpoint<
        midl.ClientEnd<DiscoverableProtocolMarker>
    >()

    constructor(public in_: midl.ClientEnd<DiscoverableProtocolMarker>) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithProtocolEndsClientEndsRequest.#fieldType0.encode(encoder, this.in_, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithProtocolEndsClientEndsRequest(
            WithProtocolEndsClientEndsRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithProtocolEndsClientEndsRequestType = new midl.StructType<WithProtocolEndsClientEndsRequest>(
    4,
    WithProtocolEndsClientEndsRequest.$decode
)

export class WithProtocolEndsClientEndsResponse implements midl.Struct {
    static #fieldType0: midl.OptionalType<midl.Endpoint<midl.ClientEnd<DiscoverableProtocolMarker>>> =
        new midl.OptionalType<midl.Endpoint<midl.ClientEnd<DiscoverableProtocolMarker>>>(
            new midl.Endpoint<midl.ClientEnd<DiscoverableProtocolMarker>>()
        )

    constructor(public out: Option<midl.ClientEnd<DiscoverableProtocolMarker>>) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithProtocolEndsClientEndsResponse.#fieldType0.encode(encoder, this.out, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithProtocolEndsClientEndsResponse(
            WithProtocolEndsClientEndsResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithProtocolEndsClientEndsResponseType = new midl.StructType<WithProtocolEndsClientEndsResponse>(
    4,
    WithProtocolEndsClientEndsResponse.$decode
)

export class WithProtocolEndsServerEndsRequest implements midl.Struct {
    static #fieldType0: midl.NullableInterfaceRequestType<DiscoverableProtocolMarker> =
        new midl.NullableInterfaceRequestType<DiscoverableProtocolMarker>()

    constructor(public in_: DiscoverableProtocolMarker | null) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithProtocolEndsServerEndsRequest.#fieldType0.encode(encoder, this.in_, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithProtocolEndsServerEndsRequest(
            WithProtocolEndsServerEndsRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithProtocolEndsServerEndsRequestType = new midl.StructType<WithProtocolEndsServerEndsRequest>(
    4,
    WithProtocolEndsServerEndsRequest.$decode
)

export class WithProtocolEndsServerEndsResponse implements midl.Struct {
    static #fieldType0: midl.InterfaceRequestType<DiscoverableProtocolMarker> =
        new midl.InterfaceRequestType<DiscoverableProtocolMarker>()

    constructor(public out: DiscoverableProtocolMarker) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithProtocolEndsServerEndsResponse.#fieldType0.encode(encoder, this.out, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithProtocolEndsServerEndsResponse(
            WithProtocolEndsServerEndsResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithProtocolEndsServerEndsResponseType = new midl.StructType<WithProtocolEndsServerEndsResponse>(
    4,
    WithProtocolEndsServerEndsResponse.$decode
)

export class WithProtocolEndsStructContainingEndsRequest implements midl.Struct {
    static #fieldType0: midl.StructType<ProtocolEnds> = _ProtocolEndsType

    constructor(public in_: ProtocolEnds) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithProtocolEndsStructContainingEndsRequest.#fieldType0.encode(encoder, this.in_, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithProtocolEndsStructContainingEndsRequest(
            WithProtocolEndsStructContainingEndsRequest.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithProtocolEndsStructContainingEndsRequestType =
    new midl.StructType<WithProtocolEndsStructContainingEndsRequest>(
        16,
        WithProtocolEndsStructContainingEndsRequest.$decode
    )

export class WithProtocolEndsStructContainingEndsResponse implements midl.Struct {
    static #fieldType0: midl.StructType<ProtocolEnds> = _ProtocolEndsType

    constructor(public out: ProtocolEnds) {}

    $encode(encoder: midl.Encoder, offset: number, depth: number): void {
        WithProtocolEndsStructContainingEndsResponse.#fieldType0.encode(encoder, this.out, offset + 0, depth)
    }

    static $decode(decoder: midl.Decoder, offset: number, depth: number) {
        return new WithProtocolEndsStructContainingEndsResponse(
            WithProtocolEndsStructContainingEndsResponse.#fieldType0.decode(decoder, offset + 0, depth)
        )
    }
}

export const _WithProtocolEndsStructContainingEndsResponseType =
    new midl.StructType<WithProtocolEndsStructContainingEndsResponse>(
        16,
        WithProtocolEndsStructContainingEndsResponse.$decode
    )

export abstract class AnotherDiscoverableProtocolMarker extends midl.Service {
    static $serviceName: string = "test.protocols.AnotherDiscoverableProtocol"

    get $serviceData(): midl.ServiceData<AnotherDiscoverableProtocolMarker> | null {
        return new AnotherDiscoverableProtocolMarkerData()
    }

    // Events
    // Oneway
    // Twoway
}

export class AnotherDiscoverableProtocolMarkerBinding extends midl.AsyncBinding<AnotherDiscoverableProtocolMarker> {
    constructor() {
        super("AnotherDiscoverableProtocolMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for AnotherDiscoverableProtocolMarkerBinding`)
            }
        }
    }
}

export class AnotherDiscoverableProtocolMarkerData implements midl.ServiceData<AnotherDiscoverableProtocolMarker> {
    get $name(): string {
        return AnotherDiscoverableProtocolMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<AnotherDiscoverableProtocolMarker> {
        return new AnotherDiscoverableProtocolMarkerBinding()
    }
}

export class AnotherDiscoverableProtocolProxy
    extends midl.AsyncProxy<AnotherDiscoverableProtocolMarker>
    implements AnotherDiscoverableProtocolMarker
{
    constructor() {
        super(
            new midl.AsyncProxyController<AnotherDiscoverableProtocolMarker>(
                "test.protocols.AnotherDiscoverableProtocol",
                "AnotherDiscoverableProtocolProxy"
            )
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<AnotherDiscoverableProtocolMarker> {
        return new AnotherDiscoverableProtocolMarkerData()
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}

export abstract class ChannelProtocolMarker extends midl.Service {
    static $serviceName: string = "test.protocols.ChannelProtocol"

    get $serviceData(): midl.ServiceData<ChannelProtocolMarker> | null {
        return new ChannelProtocolMarkerData()
    }

    // Events
    abstract get EventA(): ReadableStream<ChannelProtocolEventARequest> | null
    // Oneway
    abstract MethodA(request: midl.EmptyPayload): Promise<void>
    // Twoway
    abstract MethodB(request: midl.EmptyPayload): Promise<ChannelProtocolMethodBResponse>
    abstract TakeHandle(request: midl.EmptyPayload): Promise<midl.EmptyPayload>
    abstract MutateSocket(request: midl.EmptyPayload): Promise<ChannelProtocolMutateSocketResponse>
}

export class ChannelProtocolMarkerBinding extends midl.AsyncBinding<ChannelProtocolMarker> {
    constructor() {
        super("ChannelProtocolMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            case _ChannelProtocolMarker_MethodA_Ordinal: {
                const $name = _ChannelProtocol_MethodA_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _ChannelProtocol_MethodA_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<ChannelProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<ChannelProtocolMarker>>>(
                                $message,
                                _ChannelProtocol_MethodA_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.MethodA($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            case _ChannelProtocolMarker_EventA_Ordinal: {
                const $name = _ChannelProtocol_EventA_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _ChannelProtocol_EventA_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<ChannelProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<ChannelProtocolMarker>>>(
                                $message,
                                _ChannelProtocol_EventA_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.EventA($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            case _ChannelProtocolMarker_MethodB_Ordinal: {
                const $name = _ChannelProtocol_MethodB_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _ChannelProtocol_MethodB_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<ChannelProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<ChannelProtocolMarker>>>(
                                $message,
                                _ChannelProtocol_MethodB_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.MethodB($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _ChannelProtocolMarker_MethodB_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _ChannelProtocol_MethodB_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _ChannelProtocol_MethodB_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _ChannelProtocolMarker_TakeHandle_Ordinal: {
                const $name = _ChannelProtocol_TakeHandle_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _ChannelProtocol_TakeHandle_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<ChannelProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<ChannelProtocolMarker>>>(
                                $message,
                                _ChannelProtocol_TakeHandle_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.TakeHandle($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _ChannelProtocolMarker_TakeHandle_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _ChannelProtocol_TakeHandle_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _ChannelProtocol_TakeHandle_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _ChannelProtocolMarker_MutateSocket_Ordinal: {
                const $name = _ChannelProtocol_MutateSocket_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _ChannelProtocol_MutateSocket_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<ChannelProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<ChannelProtocolMarker>>>(
                                $message,
                                _ChannelProtocol_MutateSocket_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.MutateSocket($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _ChannelProtocolMarker_MutateSocket_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _ChannelProtocol_MutateSocket_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _ChannelProtocol_MutateSocket_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for ChannelProtocolMarkerBinding`)
            }
        }
    }
}

export class ChannelProtocolMarkerData implements midl.ServiceData<ChannelProtocolMarker> {
    get $name(): string {
        return ChannelProtocolMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<ChannelProtocolMarker> {
        return new ChannelProtocolMarkerBinding()
    }
}

export class ChannelProtocolProxy extends midl.AsyncProxy<ChannelProtocolMarker> implements ChannelProtocolMarker {
    constructor() {
        super(
            new midl.AsyncProxyController<ChannelProtocolMarker>(
                "test.protocols.ChannelProtocol",
                "ChannelProtocolProxy"
            )
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<ChannelProtocolMarker> {
        return new ChannelProtocolMarkerData()
    }
    override async MethodA(request: midl.EmptyPayload): Promise<void> {
        if (!this.ctrl.isBound) {
            return Promise.reject(new midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = new midl.Encoder()

        $encoder.encodeMessageHeader(_ChannelProtocolMarker_MethodA_Ordinal, 0, midl.CallStrictness.strict)

        const $type = _ChannelProtocol_MethodA_Type.request!

        midl.encodeMessageWithCallback($encoder, _ChannelProtocol_MethodA_Type.requestInlineSize(), () => {
            $type.encode($encoder, request, midl.kMessageHeaderSize, 1)
        })

        return Promise.resolve(this.ctrl.sendMessage($encoder.message))
    }
    override async MethodB(request: midl.EmptyPayload): Promise<ChannelProtocolMethodBResponse> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_ChannelProtocolMarker_MethodB_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<ChannelProtocolMethodBResponse>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async TakeHandle(request: midl.EmptyPayload): Promise<midl.EmptyPayload> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_ChannelProtocolMarker_TakeHandle_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<midl.EmptyPayload>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async MutateSocket(request: midl.EmptyPayload): Promise<ChannelProtocolMutateSocketResponse> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_ChannelProtocolMarker_MutateSocket_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<ChannelProtocolMutateSocketResponse>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            case _ChannelProtocolMarker_EventA_Ordinal: {
                const _name = _ChannelProtocol_EventA_Type.name
                midl.performCtrlWithExceptionHandling(
                    _name,
                    this.ctrl,
                    "event",
                    this._eventAEventStreamController.addError,
                    () => {
                        const $type = _ChannelProtocol_EventA_Type.response!

                        // ignore: prefer_const_declarations
                        const $response = midl.decodeMessageWithCallback<ChannelProtocol$EventA$Response>(
                            $message,
                            _ChannelProtocol_EventA_Type.responseInlineSize(),
                            (decoder) => {
                                return new ChannelProtocol$EventA$Response(
                                    $type.decode(decoder, midl.kMessageHeaderSize, 1)
                                )
                            }
                        )

                        this._eventAEventStreamController.add($response)
                    }
                )
                break
            }
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}
// methodA: (int a, int b)
const _ChannelProtocolMarker_MethodA_Ordinal: bigint = 3155008840945527714n
const _ChannelProtocol_MethodA_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "ChannelProtocolMarker.MethodA",
    16,
    0
)
// methodA: (int a, int b)
const _ChannelProtocolMarker_EventA_Ordinal: bigint = 2220452875311597006n
const _ChannelProtocol_EventA_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "ChannelProtocolMarker.EventA",
    16,
    0
)
// methodA: (int a, int b)
const _ChannelProtocolMarker_MethodB_Ordinal: bigint = 8903004957800778182n
const _ChannelProtocol_MethodB_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "ChannelProtocolMarker.MethodB",
    16,
    0
)
// methodA: (int a, int b)
const _ChannelProtocolMarker_TakeHandle_Ordinal: bigint = 591935489944717925n
const _ChannelProtocol_TakeHandle_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "ChannelProtocolMarker.TakeHandle",
    16,
    0
)
// methodA: (int a, int b)
const _ChannelProtocolMarker_MutateSocket_Ordinal: bigint = 7411742788430590287n
const _ChannelProtocol_MutateSocket_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "ChannelProtocolMarker.MutateSocket",
    16,
    0
)

export abstract class DiscoverableProtocolMarker extends midl.Service {
    static $serviceName: string = "test.protocols.DiscoverableProtocol"

    get $serviceData(): midl.ServiceData<DiscoverableProtocolMarker> | null {
        return new DiscoverableProtocolMarkerData()
    }

    // Events
    // Oneway
    abstract Method(request: midl.EmptyPayload): Promise<void>
    // Twoway
}

export class DiscoverableProtocolMarkerBinding extends midl.AsyncBinding<DiscoverableProtocolMarker> {
    constructor() {
        super("DiscoverableProtocolMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            case _DiscoverableProtocolMarker_Method_Ordinal: {
                const $name = _DiscoverableProtocol_Method_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _DiscoverableProtocol_Method_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<DiscoverableProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<DiscoverableProtocolMarker>>>(
                                $message,
                                _DiscoverableProtocol_Method_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.Method($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for DiscoverableProtocolMarkerBinding`)
            }
        }
    }
}

export class DiscoverableProtocolMarkerData implements midl.ServiceData<DiscoverableProtocolMarker> {
    get $name(): string {
        return DiscoverableProtocolMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<DiscoverableProtocolMarker> {
        return new DiscoverableProtocolMarkerBinding()
    }
}

export class DiscoverableProtocolProxy
    extends midl.AsyncProxy<DiscoverableProtocolMarker>
    implements DiscoverableProtocolMarker
{
    constructor() {
        super(
            new midl.AsyncProxyController<DiscoverableProtocolMarker>(
                "test.protocols.DiscoverableProtocol",
                "DiscoverableProtocolProxy"
            )
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<DiscoverableProtocolMarker> {
        return new DiscoverableProtocolMarkerData()
    }
    override async Method(request: midl.EmptyPayload): Promise<void> {
        if (!this.ctrl.isBound) {
            return Promise.reject(new midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = new midl.Encoder()

        $encoder.encodeMessageHeader(_DiscoverableProtocolMarker_Method_Ordinal, 0, midl.CallStrictness.strict)

        const $type = _DiscoverableProtocol_Method_Type.request!

        midl.encodeMessageWithCallback($encoder, _DiscoverableProtocol_Method_Type.requestInlineSize(), () => {
            $type.encode($encoder, request, midl.kMessageHeaderSize, 1)
        })

        return Promise.resolve(this.ctrl.sendMessage($encoder.message))
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}
// methodA: (int a, int b)
const _DiscoverableProtocolMarker_Method_Ordinal: bigint = 3455873048082739435n
const _DiscoverableProtocol_Method_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "DiscoverableProtocolMarker.Method",
    16,
    0
)

export abstract class HandleRightsProtocolMarker extends midl.Service {
    static $serviceName: string = "test.protocols.HandleRightsProtocol"

    get $serviceData(): midl.ServiceData<HandleRightsProtocolMarker> | null {
        return new HandleRightsProtocolMarkerData()
    }

    // Events
    abstract get AnEvent(): ReadableStream<HandleRightsProtocolAnEventRequest> | null
    // Oneway
    abstract NoResponseMethod(request: midl.EmptyPayload): Promise<void>
    // Twoway
    abstract ResponseMethod(request: midl.EmptyPayload): Promise<HandleRightsProtocolResponseMethodResponse>
}

export class HandleRightsProtocolMarkerBinding extends midl.AsyncBinding<HandleRightsProtocolMarker> {
    constructor() {
        super("HandleRightsProtocolMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            case _HandleRightsProtocolMarker_NoResponseMethod_Ordinal: {
                const $name = _HandleRightsProtocol_NoResponseMethod_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _HandleRightsProtocol_NoResponseMethod_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<HandleRightsProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<HandleRightsProtocolMarker>>>(
                                $message,
                                _HandleRightsProtocol_NoResponseMethod_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.NoResponseMethod($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            case _HandleRightsProtocolMarker_ResponseMethod_Ordinal: {
                const $name = _HandleRightsProtocol_ResponseMethod_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _HandleRightsProtocol_ResponseMethod_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<HandleRightsProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<HandleRightsProtocolMarker>>>(
                                $message,
                                _HandleRightsProtocol_ResponseMethod_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.ResponseMethod($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _HandleRightsProtocolMarker_ResponseMethod_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _HandleRightsProtocol_ResponseMethod_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _HandleRightsProtocol_ResponseMethod_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _HandleRightsProtocolMarker_AnEvent_Ordinal: {
                const $name = _HandleRightsProtocol_AnEvent_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _HandleRightsProtocol_AnEvent_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<HandleRightsProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<HandleRightsProtocolMarker>>>(
                                $message,
                                _HandleRightsProtocol_AnEvent_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.AnEvent($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for HandleRightsProtocolMarkerBinding`)
            }
        }
    }
}

export class HandleRightsProtocolMarkerData implements midl.ServiceData<HandleRightsProtocolMarker> {
    get $name(): string {
        return HandleRightsProtocolMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<HandleRightsProtocolMarker> {
        return new HandleRightsProtocolMarkerBinding()
    }
}

export class HandleRightsProtocolProxy
    extends midl.AsyncProxy<HandleRightsProtocolMarker>
    implements HandleRightsProtocolMarker
{
    constructor() {
        super(
            new midl.AsyncProxyController<HandleRightsProtocolMarker>(
                "test.protocols.HandleRightsProtocol",
                "HandleRightsProtocolProxy"
            )
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<HandleRightsProtocolMarker> {
        return new HandleRightsProtocolMarkerData()
    }
    override async NoResponseMethod(request: midl.EmptyPayload): Promise<void> {
        if (!this.ctrl.isBound) {
            return Promise.reject(new midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = new midl.Encoder()

        $encoder.encodeMessageHeader(
            _HandleRightsProtocolMarker_NoResponseMethod_Ordinal,
            0,
            midl.CallStrictness.strict
        )

        const $type = _HandleRightsProtocol_NoResponseMethod_Type.request!

        midl.encodeMessageWithCallback(
            $encoder,
            _HandleRightsProtocol_NoResponseMethod_Type.requestInlineSize(),
            () => {
                $type.encode($encoder, request, midl.kMessageHeaderSize, 1)
            }
        )

        return Promise.resolve(this.ctrl.sendMessage($encoder.message))
    }
    override async ResponseMethod(request: midl.EmptyPayload): Promise<HandleRightsProtocolResponseMethodResponse> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_HandleRightsProtocolMarker_ResponseMethod_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<HandleRightsProtocolResponseMethodResponse>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            case _HandleRightsProtocolMarker_AnEvent_Ordinal: {
                const _name = _HandleRightsProtocol_AnEvent_Type.name
                midl.performCtrlWithExceptionHandling(
                    _name,
                    this.ctrl,
                    "event",
                    this._eventAEventStreamController.addError,
                    () => {
                        const $type = _HandleRightsProtocol_AnEvent_Type.response!

                        // ignore: prefer_const_declarations
                        const $response = midl.decodeMessageWithCallback<ChannelProtocol$EventA$Response>(
                            $message,
                            _HandleRightsProtocol_AnEvent_Type.responseInlineSize(),
                            (decoder) => {
                                return new ChannelProtocol$EventA$Response(
                                    $type.decode(decoder, midl.kMessageHeaderSize, 1)
                                )
                            }
                        )

                        this._eventAEventStreamController.add($response)
                    }
                )
                break
            }
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}
// methodA: (int a, int b)
const _HandleRightsProtocolMarker_NoResponseMethod_Ordinal: bigint = 1155044649514904573n
const _HandleRightsProtocol_NoResponseMethod_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "HandleRightsProtocolMarker.NoResponseMethod",
    16,
    0
)
// methodA: (int a, int b)
const _HandleRightsProtocolMarker_ResponseMethod_Ordinal: bigint = 5956276128041940295n
const _HandleRightsProtocol_ResponseMethod_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "HandleRightsProtocolMarker.ResponseMethod",
    16,
    0
)
// methodA: (int a, int b)
const _HandleRightsProtocolMarker_AnEvent_Ordinal: bigint = 476727631355490611n
const _HandleRightsProtocol_AnEvent_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "HandleRightsProtocolMarker.AnEvent",
    16,
    0
)

export abstract class ManyParametersMarker extends midl.Service {
    static $serviceName: string = "test.protocols.ManyParameters"

    get $serviceData(): midl.ServiceData<ManyParametersMarker> | null {
        return new ManyParametersMarkerData()
    }

    // Events
    // Oneway
    abstract Fifteen(request: midl.EmptyPayload): Promise<void>
    // Twoway
}

export class ManyParametersMarkerBinding extends midl.AsyncBinding<ManyParametersMarker> {
    constructor() {
        super("ManyParametersMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            case _ManyParametersMarker_Fifteen_Ordinal: {
                const $name = _ManyParameters_Fifteen_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _ManyParameters_Fifteen_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<ManyParametersMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<ManyParametersMarker>>>(
                                $message,
                                _ManyParameters_Fifteen_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.Fifteen($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for ManyParametersMarkerBinding`)
            }
        }
    }
}

export class ManyParametersMarkerData implements midl.ServiceData<ManyParametersMarker> {
    get $name(): string {
        return ManyParametersMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<ManyParametersMarker> {
        return new ManyParametersMarkerBinding()
    }
}

export class ManyParametersProxy extends midl.AsyncProxy<ManyParametersMarker> implements ManyParametersMarker {
    constructor() {
        super(
            new midl.AsyncProxyController<ManyParametersMarker>("test.protocols.ManyParameters", "ManyParametersProxy")
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<ManyParametersMarker> {
        return new ManyParametersMarkerData()
    }
    override async Fifteen(request: midl.EmptyPayload): Promise<void> {
        if (!this.ctrl.isBound) {
            return Promise.reject(new midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = new midl.Encoder()

        $encoder.encodeMessageHeader(_ManyParametersMarker_Fifteen_Ordinal, 0, midl.CallStrictness.strict)

        const $type = _ManyParameters_Fifteen_Type.request!

        midl.encodeMessageWithCallback($encoder, _ManyParameters_Fifteen_Type.requestInlineSize(), () => {
            $type.encode($encoder, request, midl.kMessageHeaderSize, 1)
        })

        return Promise.resolve(this.ctrl.sendMessage($encoder.message))
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}
// methodA: (int a, int b)
const _ManyParametersMarker_Fifteen_Ordinal: bigint = 6423043252952467815n
const _ManyParameters_Fifteen_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "ManyParametersMarker.Fifteen",
    16,
    0
)

export abstract class MethodWithUnionMarker extends midl.Service {
    static $serviceName: string = "test.protocols.MethodWithUnion"

    get $serviceData(): midl.ServiceData<MethodWithUnionMarker> | null {
        return new MethodWithUnionMarkerData()
    }

    // Events
    // Oneway
    // Twoway
    abstract UnionMethod(request: midl.EmptyPayload): Promise<MethodWithUnionUnionMethodResponse>
}

export class MethodWithUnionMarkerBinding extends midl.AsyncBinding<MethodWithUnionMarker> {
    constructor() {
        super("MethodWithUnionMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            case _MethodWithUnionMarker_UnionMethod_Ordinal: {
                const $name = _MethodWithUnion_UnionMethod_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _MethodWithUnion_UnionMethod_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<MethodWithUnionMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<MethodWithUnionMarker>>>(
                                $message,
                                _MethodWithUnion_UnionMethod_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.UnionMethod($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _MethodWithUnionMarker_UnionMethod_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _MethodWithUnion_UnionMethod_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _MethodWithUnion_UnionMethod_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for MethodWithUnionMarkerBinding`)
            }
        }
    }
}

export class MethodWithUnionMarkerData implements midl.ServiceData<MethodWithUnionMarker> {
    get $name(): string {
        return MethodWithUnionMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<MethodWithUnionMarker> {
        return new MethodWithUnionMarkerBinding()
    }
}

export class MethodWithUnionProxy extends midl.AsyncProxy<MethodWithUnionMarker> implements MethodWithUnionMarker {
    constructor() {
        super(
            new midl.AsyncProxyController<MethodWithUnionMarker>(
                "test.protocols.MethodWithUnion",
                "MethodWithUnionProxy"
            )
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<MethodWithUnionMarker> {
        return new MethodWithUnionMarkerData()
    }
    override async UnionMethod(request: midl.EmptyPayload): Promise<MethodWithUnionUnionMethodResponse> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_MethodWithUnionMarker_UnionMethod_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<MethodWithUnionUnionMethodResponse>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}
// methodA: (int a, int b)
const _MethodWithUnionMarker_UnionMethod_Ordinal: bigint = 4124874338266649112n
const _MethodWithUnion_UnionMethod_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "MethodWithUnionMarker.UnionMethod",
    16,
    0
)

export abstract class PlatformServerMarker extends midl.Service {
    static $serviceName: string = "test.protocols.PlatformServer"

    get $serviceData(): midl.ServiceData<PlatformServerMarker> | null {
        return new PlatformServerMarkerData()
    }

    // Events
    // Oneway
    // Twoway
}

export class PlatformServerMarkerBinding extends midl.AsyncBinding<PlatformServerMarker> {
    constructor() {
        super("PlatformServerMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for PlatformServerMarkerBinding`)
            }
        }
    }
}

export class PlatformServerMarkerData implements midl.ServiceData<PlatformServerMarker> {
    get $name(): string {
        return PlatformServerMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<PlatformServerMarker> {
        return new PlatformServerMarkerBinding()
    }
}

export class PlatformServerProxy extends midl.AsyncProxy<PlatformServerMarker> implements PlatformServerMarker {
    constructor() {
        super(
            new midl.AsyncProxyController<PlatformServerMarker>("test.protocols.PlatformServer", "PlatformServerProxy")
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<PlatformServerMarker> {
        return new PlatformServerMarkerData()
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}

export abstract class SyscallProtocolMarker extends midl.Service {
    static $serviceName: string = "test.protocols.SyscallProtocol"

    get $serviceData(): midl.ServiceData<SyscallProtocolMarker> | null {
        return new SyscallProtocolMarkerData()
    }

    // Events
    // Oneway
    abstract MethodC(request: midl.EmptyPayload): Promise<void>
    // Twoway
}

export class SyscallProtocolMarkerBinding extends midl.AsyncBinding<SyscallProtocolMarker> {
    constructor() {
        super("SyscallProtocolMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            case _SyscallProtocolMarker_MethodC_Ordinal: {
                const $name = _SyscallProtocol_MethodC_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _SyscallProtocol_MethodC_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<SyscallProtocolMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<SyscallProtocolMarker>>>(
                                $message,
                                _SyscallProtocol_MethodC_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.MethodC($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for SyscallProtocolMarkerBinding`)
            }
        }
    }
}

export class SyscallProtocolMarkerData implements midl.ServiceData<SyscallProtocolMarker> {
    get $name(): string {
        return SyscallProtocolMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<SyscallProtocolMarker> {
        return new SyscallProtocolMarkerBinding()
    }
}

export class SyscallProtocolProxy extends midl.AsyncProxy<SyscallProtocolMarker> implements SyscallProtocolMarker {
    constructor() {
        super(
            new midl.AsyncProxyController<SyscallProtocolMarker>(
                "test.protocols.SyscallProtocol",
                "SyscallProtocolProxy"
            )
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<SyscallProtocolMarker> {
        return new SyscallProtocolMarkerData()
    }
    override async MethodC(request: midl.EmptyPayload): Promise<void> {
        if (!this.ctrl.isBound) {
            return Promise.reject(new midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = new midl.Encoder()

        $encoder.encodeMessageHeader(_SyscallProtocolMarker_MethodC_Ordinal, 0, midl.CallStrictness.strict)

        const $type = _SyscallProtocol_MethodC_Type.request!

        midl.encodeMessageWithCallback($encoder, _SyscallProtocol_MethodC_Type.requestInlineSize(), () => {
            $type.encode($encoder, request, midl.kMessageHeaderSize, 1)
        })

        return Promise.resolve(this.ctrl.sendMessage($encoder.message))
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}
// methodA: (int a, int b)
const _SyscallProtocolMarker_MethodC_Ordinal: bigint = 1468025868259603279n
const _SyscallProtocol_MethodC_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "SyscallProtocolMarker.MethodC",
    16,
    0
)

export abstract class WithAndWithoutRequestResponseMarker extends midl.Service {
    static $serviceName: string = "test.protocols.WithAndWithoutRequestResponse"

    get $serviceData(): midl.ServiceData<WithAndWithoutRequestResponseMarker> | null {
        return new WithAndWithoutRequestResponseMarkerData()
    }

    // Events
    abstract get OnEmptyResponse(): ReadableStream<midl.EmptyPayload> | null
    abstract get OnWithResponse(): ReadableStream<WithAndWithoutRequestResponseOnWithResponseRequest> | null
    // Oneway
    abstract NoRequestNoResponse(request: midl.EmptyPayload): Promise<void>
    abstract WithRequestNoResponse(request: midl.EmptyPayload): Promise<void>
    // Twoway
    abstract NoRequestEmptyResponse(request: midl.EmptyPayload): Promise<midl.EmptyPayload>
    abstract NoRequestWithResponse(
        request: midl.EmptyPayload
    ): Promise<WithAndWithoutRequestResponseNoRequestWithResponseResponse>
    abstract WithRequestEmptyResponse(request: midl.EmptyPayload): Promise<midl.EmptyPayload>
    abstract WithRequestWithResponse(
        request: midl.EmptyPayload
    ): Promise<WithAndWithoutRequestResponseWithRequestWithResponseResponse>
}

export class WithAndWithoutRequestResponseMarkerBinding extends midl.AsyncBinding<WithAndWithoutRequestResponseMarker> {
    constructor() {
        super("WithAndWithoutRequestResponseMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            case _WithAndWithoutRequestResponseMarker_NoRequestNoResponse_Ordinal: {
                const $name = _WithAndWithoutRequestResponse_NoRequestNoResponse_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_NoRequestNoResponse_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>> =
                            midl.decodeMessageWithCallback<
                                Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>>
                            >(
                                $message,
                                _WithAndWithoutRequestResponse_NoRequestNoResponse_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.NoRequestNoResponse($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            case _WithAndWithoutRequestResponseMarker_NoRequestEmptyResponse_Ordinal: {
                const $name = _WithAndWithoutRequestResponse_NoRequestEmptyResponse_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_NoRequestEmptyResponse_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>> =
                            midl.decodeMessageWithCallback<
                                Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>>
                            >(
                                $message,
                                _WithAndWithoutRequestResponse_NoRequestEmptyResponse_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.NoRequestEmptyResponse(
                                        $type.decode(decoder, midl.kMessageHeaderSize, 1)
                                    )
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithAndWithoutRequestResponseMarker_NoRequestEmptyResponse_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType =
                                    _WithAndWithoutRequestResponse_NoRequestEmptyResponse_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithAndWithoutRequestResponse_NoRequestEmptyResponse_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _WithAndWithoutRequestResponseMarker_NoRequestWithResponse_Ordinal: {
                const $name = _WithAndWithoutRequestResponse_NoRequestWithResponse_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_NoRequestWithResponse_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>> =
                            midl.decodeMessageWithCallback<
                                Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>>
                            >(
                                $message,
                                _WithAndWithoutRequestResponse_NoRequestWithResponse_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.NoRequestWithResponse(
                                        $type.decode(decoder, midl.kMessageHeaderSize, 1)
                                    )
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithAndWithoutRequestResponseMarker_NoRequestWithResponse_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType =
                                    _WithAndWithoutRequestResponse_NoRequestWithResponse_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithAndWithoutRequestResponse_NoRequestWithResponse_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _WithAndWithoutRequestResponseMarker_WithRequestNoResponse_Ordinal: {
                const $name = _WithAndWithoutRequestResponse_WithRequestNoResponse_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_WithRequestNoResponse_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>> =
                            midl.decodeMessageWithCallback<
                                Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>>
                            >(
                                $message,
                                _WithAndWithoutRequestResponse_WithRequestNoResponse_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.WithRequestNoResponse(
                                        $type.decode(decoder, midl.kMessageHeaderSize, 1)
                                    )
                                }
                            )
                    },
                    close
                )
                break
            }
            case _WithAndWithoutRequestResponseMarker_WithRequestEmptyResponse_Ordinal: {
                const $name = _WithAndWithoutRequestResponse_WithRequestEmptyResponse_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_WithRequestEmptyResponse_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>> =
                            midl.decodeMessageWithCallback<
                                Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>>
                            >(
                                $message,
                                _WithAndWithoutRequestResponse_WithRequestEmptyResponse_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.WithRequestEmptyResponse(
                                        $type.decode(decoder, midl.kMessageHeaderSize, 1)
                                    )
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithAndWithoutRequestResponseMarker_WithRequestEmptyResponse_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType =
                                    _WithAndWithoutRequestResponse_WithRequestEmptyResponse_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithAndWithoutRequestResponse_WithRequestEmptyResponse_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _WithAndWithoutRequestResponseMarker_WithRequestWithResponse_Ordinal: {
                const $name = _WithAndWithoutRequestResponse_WithRequestWithResponse_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_WithRequestWithResponse_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>> =
                            midl.decodeMessageWithCallback<
                                Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>>
                            >(
                                $message,
                                _WithAndWithoutRequestResponse_WithRequestWithResponse_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.WithRequestWithResponse(
                                        $type.decode(decoder, midl.kMessageHeaderSize, 1)
                                    )
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithAndWithoutRequestResponseMarker_WithRequestWithResponse_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType =
                                    _WithAndWithoutRequestResponse_WithRequestWithResponse_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithAndWithoutRequestResponse_WithRequestWithResponse_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _WithAndWithoutRequestResponseMarker_OnEmptyResponse_Ordinal: {
                const $name = _WithAndWithoutRequestResponse_OnEmptyResponse_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_OnEmptyResponse_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>> =
                            midl.decodeMessageWithCallback<
                                Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>>
                            >(
                                $message,
                                _WithAndWithoutRequestResponse_OnEmptyResponse_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.OnEmptyResponse($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            case _WithAndWithoutRequestResponseMarker_OnWithResponse_Ordinal: {
                const $name = _WithAndWithoutRequestResponse_OnWithResponse_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_OnWithResponse_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>> =
                            midl.decodeMessageWithCallback<
                                Promise<midl.InterfaceRequest<WithAndWithoutRequestResponseMarker>>
                            >(
                                $message,
                                _WithAndWithoutRequestResponse_OnWithResponse_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.OnWithResponse($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                    },
                    close
                )
                break
            }
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for WithAndWithoutRequestResponseMarkerBinding`)
            }
        }
    }
}

export class WithAndWithoutRequestResponseMarkerData implements midl.ServiceData<WithAndWithoutRequestResponseMarker> {
    get $name(): string {
        return WithAndWithoutRequestResponseMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<WithAndWithoutRequestResponseMarker> {
        return new WithAndWithoutRequestResponseMarkerBinding()
    }
}

export class WithAndWithoutRequestResponseProxy
    extends midl.AsyncProxy<WithAndWithoutRequestResponseMarker>
    implements WithAndWithoutRequestResponseMarker
{
    constructor() {
        super(
            new midl.AsyncProxyController<WithAndWithoutRequestResponseMarker>(
                "test.protocols.WithAndWithoutRequestResponse",
                "WithAndWithoutRequestResponseProxy"
            )
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<WithAndWithoutRequestResponseMarker> {
        return new WithAndWithoutRequestResponseMarkerData()
    }
    override async NoRequestNoResponse(request: midl.EmptyPayload): Promise<void> {
        if (!this.ctrl.isBound) {
            return Promise.reject(new midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = new midl.Encoder()

        $encoder.encodeMessageHeader(
            _WithAndWithoutRequestResponseMarker_NoRequestNoResponse_Ordinal,
            0,
            midl.CallStrictness.strict
        )

        const $type = _WithAndWithoutRequestResponse_NoRequestNoResponse_Type.request!

        midl.encodeMessageWithCallback(
            $encoder,
            _WithAndWithoutRequestResponse_NoRequestNoResponse_Type.requestInlineSize(),
            () => {
                $type.encode($encoder, request, midl.kMessageHeaderSize, 1)
            }
        )

        return Promise.resolve(this.ctrl.sendMessage($encoder.message))
    }
    override async WithRequestNoResponse(request: midl.EmptyPayload): Promise<void> {
        if (!this.ctrl.isBound) {
            return Promise.reject(new midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = new midl.Encoder()

        $encoder.encodeMessageHeader(
            _WithAndWithoutRequestResponseMarker_WithRequestNoResponse_Ordinal,
            0,
            midl.CallStrictness.strict
        )

        const $type = _WithAndWithoutRequestResponse_WithRequestNoResponse_Type.request!

        midl.encodeMessageWithCallback(
            $encoder,
            _WithAndWithoutRequestResponse_WithRequestNoResponse_Type.requestInlineSize(),
            () => {
                $type.encode($encoder, request, midl.kMessageHeaderSize, 1)
            }
        )

        return Promise.resolve(this.ctrl.sendMessage($encoder.message))
    }
    override async NoRequestEmptyResponse(request: midl.EmptyPayload): Promise<midl.EmptyPayload> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(
            _WithAndWithoutRequestResponseMarker_NoRequestEmptyResponse_Ordinal,
            0,
            midl.CallStrictness.strict
        )

        const $completer = new midl.Completer<midl.EmptyPayload>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async NoRequestWithResponse(
        request: midl.EmptyPayload
    ): Promise<WithAndWithoutRequestResponseNoRequestWithResponseResponse> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(
            _WithAndWithoutRequestResponseMarker_NoRequestWithResponse_Ordinal,
            0,
            midl.CallStrictness.strict
        )

        const $completer = new midl.Completer<WithAndWithoutRequestResponseNoRequestWithResponseResponse>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async WithRequestEmptyResponse(request: midl.EmptyPayload): Promise<midl.EmptyPayload> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(
            _WithAndWithoutRequestResponseMarker_WithRequestEmptyResponse_Ordinal,
            0,
            midl.CallStrictness.strict
        )

        const $completer = new midl.Completer<midl.EmptyPayload>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async WithRequestWithResponse(
        request: midl.EmptyPayload
    ): Promise<WithAndWithoutRequestResponseWithRequestWithResponseResponse> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(
            _WithAndWithoutRequestResponseMarker_WithRequestWithResponse_Ordinal,
            0,
            midl.CallStrictness.strict
        )

        const $completer = new midl.Completer<WithAndWithoutRequestResponseWithRequestWithResponseResponse>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            case _WithAndWithoutRequestResponseMarker_OnEmptyResponse_Ordinal: {
                const _name = _WithAndWithoutRequestResponse_OnEmptyResponse_Type.name
                midl.performCtrlWithExceptionHandling(
                    _name,
                    this.ctrl,
                    "event",
                    this._eventAEventStreamController.addError,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_OnEmptyResponse_Type.response!

                        // ignore: prefer_const_declarations
                        const $response = midl.decodeMessageWithCallback<ChannelProtocol$EventA$Response>(
                            $message,
                            _WithAndWithoutRequestResponse_OnEmptyResponse_Type.responseInlineSize(),
                            (decoder) => {
                                return new ChannelProtocol$EventA$Response(
                                    $type.decode(decoder, midl.kMessageHeaderSize, 1)
                                )
                            }
                        )

                        this._eventAEventStreamController.add($response)
                    }
                )
                break
            }
            case _WithAndWithoutRequestResponseMarker_OnWithResponse_Ordinal: {
                const _name = _WithAndWithoutRequestResponse_OnWithResponse_Type.name
                midl.performCtrlWithExceptionHandling(
                    _name,
                    this.ctrl,
                    "event",
                    this._eventAEventStreamController.addError,
                    () => {
                        const $type = _WithAndWithoutRequestResponse_OnWithResponse_Type.response!

                        // ignore: prefer_const_declarations
                        const $response = midl.decodeMessageWithCallback<ChannelProtocol$EventA$Response>(
                            $message,
                            _WithAndWithoutRequestResponse_OnWithResponse_Type.responseInlineSize(),
                            (decoder) => {
                                return new ChannelProtocol$EventA$Response(
                                    $type.decode(decoder, midl.kMessageHeaderSize, 1)
                                )
                            }
                        )

                        this._eventAEventStreamController.add($response)
                    }
                )
                break
            }
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}
// methodA: (int a, int b)
const _WithAndWithoutRequestResponseMarker_NoRequestNoResponse_Ordinal: bigint = 5413654872775949227n
const _WithAndWithoutRequestResponse_NoRequestNoResponse_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithAndWithoutRequestResponseMarker.NoRequestNoResponse",
    16,
    0
)
// methodA: (int a, int b)
const _WithAndWithoutRequestResponseMarker_NoRequestEmptyResponse_Ordinal: bigint = 1631193469798418024n
const _WithAndWithoutRequestResponse_NoRequestEmptyResponse_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithAndWithoutRequestResponseMarker.NoRequestEmptyResponse",
    16,
    0
)
// methodA: (int a, int b)
const _WithAndWithoutRequestResponseMarker_NoRequestWithResponse_Ordinal: bigint = 9037369643591427517n
const _WithAndWithoutRequestResponse_NoRequestWithResponse_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithAndWithoutRequestResponseMarker.NoRequestWithResponse",
    16,
    0
)
// methodA: (int a, int b)
const _WithAndWithoutRequestResponseMarker_WithRequestNoResponse_Ordinal: bigint = 7326057319832554103n
const _WithAndWithoutRequestResponse_WithRequestNoResponse_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithAndWithoutRequestResponseMarker.WithRequestNoResponse",
    16,
    0
)
// methodA: (int a, int b)
const _WithAndWithoutRequestResponseMarker_WithRequestEmptyResponse_Ordinal: bigint = 2877322062572412767n
const _WithAndWithoutRequestResponse_WithRequestEmptyResponse_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithAndWithoutRequestResponseMarker.WithRequestEmptyResponse",
    16,
    0
)
// methodA: (int a, int b)
const _WithAndWithoutRequestResponseMarker_WithRequestWithResponse_Ordinal: bigint = 6417226585456833969n
const _WithAndWithoutRequestResponse_WithRequestWithResponse_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithAndWithoutRequestResponseMarker.WithRequestWithResponse",
    16,
    0
)
// methodA: (int a, int b)
const _WithAndWithoutRequestResponseMarker_OnEmptyResponse_Ordinal: bigint = 5397663296507358806n
const _WithAndWithoutRequestResponse_OnEmptyResponse_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithAndWithoutRequestResponseMarker.OnEmptyResponse",
    16,
    0
)
// methodA: (int a, int b)
const _WithAndWithoutRequestResponseMarker_OnWithResponse_Ordinal: bigint = 5811598563493228968n
const _WithAndWithoutRequestResponse_OnWithResponse_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithAndWithoutRequestResponseMarker.OnWithResponse",
    16,
    0
)

export abstract class WithErrorSyntaxMarker extends midl.Service {
    static $serviceName: string = "test.protocols.WithErrorSyntax"

    get $serviceData(): midl.ServiceData<WithErrorSyntaxMarker> | null {
        return new WithErrorSyntaxMarkerData()
    }

    // Events
    // Oneway
    // Twoway
    abstract ResponseAsStruct(
        request: midl.EmptyPayload
    ): Promise<midl.ResultType<WithErrorSyntaxResponseAsStructResponse, midl.UInt32Type>>
    abstract ErrorAsPrimitive(request: midl.EmptyPayload): Promise<midl.ResultType<midl.EmptyStruct, midl.UInt32Type>>
    abstract ErrorAsEnum(
        request: midl.EmptyPayload
    ): Promise<midl.ResultType<midl.EmptyStruct, midl.EnumType<ErrorEnum>>>
    abstract HandleInResult(
        request: midl.EmptyPayload
    ): Promise<midl.ResultType<WithErrorSyntaxHandleInResultResponse, midl.UInt32Type>>
}

export class WithErrorSyntaxMarkerBinding extends midl.AsyncBinding<WithErrorSyntaxMarker> {
    constructor() {
        super("WithErrorSyntaxMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            case _WithErrorSyntaxMarker_ResponseAsStruct_Ordinal: {
                const $name = _WithErrorSyntax_ResponseAsStruct_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithErrorSyntax_ResponseAsStruct_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithErrorSyntaxMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<WithErrorSyntaxMarker>>>(
                                $message,
                                _WithErrorSyntax_ResponseAsStruct_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.ResponseAsStruct($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithErrorSyntaxMarker_ResponseAsStruct_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _WithErrorSyntax_ResponseAsStruct_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithErrorSyntax_ResponseAsStruct_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _WithErrorSyntaxMarker_ErrorAsPrimitive_Ordinal: {
                const $name = _WithErrorSyntax_ErrorAsPrimitive_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithErrorSyntax_ErrorAsPrimitive_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithErrorSyntaxMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<WithErrorSyntaxMarker>>>(
                                $message,
                                _WithErrorSyntax_ErrorAsPrimitive_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.ErrorAsPrimitive($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithErrorSyntaxMarker_ErrorAsPrimitive_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _WithErrorSyntax_ErrorAsPrimitive_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithErrorSyntax_ErrorAsPrimitive_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _WithErrorSyntaxMarker_ErrorAsEnum_Ordinal: {
                const $name = _WithErrorSyntax_ErrorAsEnum_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithErrorSyntax_ErrorAsEnum_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithErrorSyntaxMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<WithErrorSyntaxMarker>>>(
                                $message,
                                _WithErrorSyntax_ErrorAsEnum_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.ErrorAsEnum($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithErrorSyntaxMarker_ErrorAsEnum_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _WithErrorSyntax_ErrorAsEnum_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithErrorSyntax_ErrorAsEnum_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _WithErrorSyntaxMarker_HandleInResult_Ordinal: {
                const $name = _WithErrorSyntax_HandleInResult_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithErrorSyntax_HandleInResult_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithErrorSyntaxMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<WithErrorSyntaxMarker>>>(
                                $message,
                                _WithErrorSyntax_HandleInResult_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.HandleInResult($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithErrorSyntaxMarker_HandleInResult_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _WithErrorSyntax_HandleInResult_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithErrorSyntax_HandleInResult_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for WithErrorSyntaxMarkerBinding`)
            }
        }
    }
}

export class WithErrorSyntaxMarkerData implements midl.ServiceData<WithErrorSyntaxMarker> {
    get $name(): string {
        return WithErrorSyntaxMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<WithErrorSyntaxMarker> {
        return new WithErrorSyntaxMarkerBinding()
    }
}

export class WithErrorSyntaxProxy extends midl.AsyncProxy<WithErrorSyntaxMarker> implements WithErrorSyntaxMarker {
    constructor() {
        super(
            new midl.AsyncProxyController<WithErrorSyntaxMarker>(
                "test.protocols.WithErrorSyntax",
                "WithErrorSyntaxProxy"
            )
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<WithErrorSyntaxMarker> {
        return new WithErrorSyntaxMarkerData()
    }
    override async ResponseAsStruct(
        request: midl.EmptyPayload
    ): Promise<midl.ResultType<WithErrorSyntaxResponseAsStructResponse, midl.UInt32Type>> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_WithErrorSyntaxMarker_ResponseAsStruct_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<
            midl.ResultType<WithErrorSyntaxResponseAsStructResponse, midl.UInt32Type>
        >()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async ErrorAsPrimitive(
        request: midl.EmptyPayload
    ): Promise<midl.ResultType<midl.EmptyStruct, midl.UInt32Type>> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_WithErrorSyntaxMarker_ErrorAsPrimitive_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<midl.ResultType<midl.EmptyStruct, midl.UInt32Type>>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async ErrorAsEnum(
        request: midl.EmptyPayload
    ): Promise<midl.ResultType<midl.EmptyStruct, midl.EnumType<ErrorEnum>>> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_WithErrorSyntaxMarker_ErrorAsEnum_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<midl.ResultType<midl.EmptyStruct, midl.EnumType<ErrorEnum>>>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async HandleInResult(
        request: midl.EmptyPayload
    ): Promise<midl.ResultType<WithErrorSyntaxHandleInResultResponse, midl.UInt32Type>> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_WithErrorSyntaxMarker_HandleInResult_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<midl.ResultType<WithErrorSyntaxHandleInResultResponse, midl.UInt32Type>>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}
// methodA: (int a, int b)
const _WithErrorSyntaxMarker_ResponseAsStruct_Ordinal: bigint = 268248568430741139n
const _WithErrorSyntax_ResponseAsStruct_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithErrorSyntaxMarker.ResponseAsStruct",
    16,
    0
)
// methodA: (int a, int b)
const _WithErrorSyntaxMarker_ErrorAsPrimitive_Ordinal: bigint = 6930994461233198567n
const _WithErrorSyntax_ErrorAsPrimitive_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithErrorSyntaxMarker.ErrorAsPrimitive",
    16,
    0
)
// methodA: (int a, int b)
const _WithErrorSyntaxMarker_ErrorAsEnum_Ordinal: bigint = 5491891352371277635n
const _WithErrorSyntax_ErrorAsEnum_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithErrorSyntaxMarker.ErrorAsEnum",
    16,
    0
)
// methodA: (int a, int b)
const _WithErrorSyntaxMarker_HandleInResult_Ordinal: bigint = 1371676333068455103n
const _WithErrorSyntax_HandleInResult_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithErrorSyntaxMarker.HandleInResult",
    16,
    0
)

export abstract class WithProtocolEndsMarker extends midl.Service {
    static $serviceName: string = "test.protocols.WithProtocolEnds"

    get $serviceData(): midl.ServiceData<WithProtocolEndsMarker> | null {
        return new WithProtocolEndsMarkerData()
    }

    // Events
    // Oneway
    // Twoway
    abstract ClientEnds(request: midl.EmptyPayload): Promise<WithProtocolEndsClientEndsResponse>
    abstract ServerEnds_(request: midl.EmptyPayload): Promise<WithProtocolEndsServerEndsResponse>
    abstract StructContainingEnds(request: midl.EmptyPayload): Promise<WithProtocolEndsStructContainingEndsResponse>
}

export class WithProtocolEndsMarkerBinding extends midl.AsyncBinding<WithProtocolEndsMarker> {
    constructor() {
        super("WithProtocolEndsMarker")
    }

    override handleMessage($message: midl.IncomingMessage, $respond: midl.OutgoingMessageSink) {
        switch ($message.ordinal) {
            case _WithProtocolEndsMarker_ClientEnds_Ordinal: {
                const $name = _WithProtocolEnds_ClientEnds_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithProtocolEnds_ClientEnds_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithProtocolEndsMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<WithProtocolEndsMarker>>>(
                                $message,
                                _WithProtocolEnds_ClientEnds_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.ClientEnds($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithProtocolEndsMarker_ClientEnds_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _WithProtocolEnds_ClientEnds_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithProtocolEnds_ClientEnds_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _WithProtocolEndsMarker_ServerEnds__Ordinal: {
                const $name = _WithProtocolEnds_ServerEnds_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithProtocolEnds_ServerEnds_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithProtocolEndsMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<WithProtocolEndsMarker>>>(
                                $message,
                                _WithProtocolEnds_ServerEnds_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.ServerEnds_($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithProtocolEndsMarker_ServerEnds__Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _WithProtocolEnds_ServerEnds_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithProtocolEnds_ServerEnds_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            case _WithProtocolEndsMarker_StructContainingEnds_Ordinal: {
                const $name = _WithProtocolEnds_StructContainingEnds_Type.name
                midl.performWithExceptionHandling(
                    $name,
                    () => {
                        const $type = _WithProtocolEnds_StructContainingEnds_Type.request!

                        const _impl = this.impl!

                        const $future: Promise<midl.InterfaceRequest<WithProtocolEndsMarker>> =
                            midl.decodeMessageWithCallback<Promise<midl.InterfaceRequest<WithProtocolEndsMarker>>>(
                                $message,
                                _WithProtocolEnds_StructContainingEnds_Type.requestInlineSize(),
                                (decoder) => {
                                    return _impl.StructContainingEnds($type.decode(decoder, midl.kMessageHeaderSize, 1))
                                }
                            )
                        $future.then(
                            ($response) => {
                                const $encoder: midl.Encoder = new midl.Encoder()
                                $encoder.encodeMessageHeader(
                                    _WithProtocolEndsMarker_StructContainingEnds_Ordinal,
                                    $message.txid,
                                    midl.CallStrictness.strict
                                )
                                const $type: midl.MemberType = _WithProtocolEnds_StructContainingEnds_Type.response

                                midl.encodeMessage(
                                    $encoder,
                                    _WithProtocolEnds_StructContainingEnds_Type.responseInlineSize(),
                                    $type,
                                    $response
                                )

                                $respond($encoder.message)
                            },
                            ($err) => {
                                midl.handleException($name, $err, close)
                            }
                        )
                    },
                    close
                )
                break
            }
            default: {
                $message.closeHandles()
                throw new midl.MidlError(`Unexpected message name for WithProtocolEndsMarkerBinding`)
            }
        }
    }
}

export class WithProtocolEndsMarkerData implements midl.ServiceData<WithProtocolEndsMarker> {
    get $name(): string {
        return WithProtocolEndsMarker.$serviceName
    }

    get $binding(): midl.AsyncBinding<WithProtocolEndsMarker> {
        return new WithProtocolEndsMarkerBinding()
    }
}

export class WithProtocolEndsProxy extends midl.AsyncProxy<WithProtocolEndsMarker> implements WithProtocolEndsMarker {
    constructor() {
        super(
            new midl.AsyncProxyController<WithProtocolEndsMarker>(
                "test.protocols.WithProtocolEnds",
                "WithProtocolEndsProxy"
            )
        )
        this.ctrl.onResponse = this._handleResponse
    }

    get $serviceData(): midl.ServiceData<WithProtocolEndsMarker> {
        return new WithProtocolEndsMarkerData()
    }
    override async ClientEnds(request: midl.EmptyPayload): Promise<WithProtocolEndsClientEndsResponse> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_WithProtocolEndsMarker_ClientEnds_Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<WithProtocolEndsClientEndsResponse>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async ServerEnds_(request: midl.EmptyPayload): Promise<WithProtocolEndsServerEndsResponse> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(_WithProtocolEndsMarker_ServerEnds__Ordinal, 0, midl.CallStrictness.strict)

        const $completer = new midl.Completer<WithProtocolEndsServerEndsResponse>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }
    override async StructContainingEnds(
        request: midl.EmptyPayload
    ): Promise<WithProtocolEndsStructContainingEndsResponse> {
        if (!this.ctrl.isBound) {
            return Promise.reject(midl.MidlStateException("Proxy<${ctrl.$interfaceName}> is closed."))
        }

        const $encoder = midl.Encoder()

        $encoder.encodeMessageHeader(
            _WithProtocolEndsMarker_StructContainingEnds_Ordinal,
            0,
            midl.CallStrictness.strict
        )

        const $completer = new midl.Completer<WithProtocolEndsStructContainingEndsResponse>()
        this.ctrl.sendMessageWithResponse($encoder.message, $completer)
        return $completer.promise
    }

    _handleEvent($message: midl.IncomingMessage): void {
        switch ($message.ordinal) {
            default: {
                $message.closeHandles()
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }

    _handleResponse($message: midl.IncomingMessage): void {
        const $txid = $message.txid
        if ($txid === 0) {
            this._handleEvent($message)
            return
        }

        const $completer: midl.Completer<any> | null = this.ctrl.getCompleter($txid)
        if ($completer === null) {
            $message.closeHandles()
            return
        }

        switch ($message.ordinal) {
            default: {
                this.ctrl.proxyError(new midl.MidlError(`Unexpected message ordinal: ${$message.ordinal}`))
                break
            }
        }
    }
}
// methodA: (int a, int b)
const _WithProtocolEndsMarker_ClientEnds_Ordinal: bigint = 5870448041025163330n
const _WithProtocolEnds_ClientEnds_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithProtocolEndsMarker.ClientEnds",
    16,
    0
)
// methodA: (int a, int b)
const _WithProtocolEndsMarker_ServerEnds__Ordinal: bigint = 8115535094437022259n
const _WithProtocolEnds_ServerEnds_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithProtocolEndsMarker.ServerEnds_",
    16,
    0
)
// methodA: (int a, int b)
const _WithProtocolEndsMarker_StructContainingEnds_Ordinal: bigint = 4076866772260025813n
const _WithProtocolEnds_StructContainingEnds_Type = new midl.MethodType(
    new midl.MemberType<number>(new midl.Int64Type(), 0),
    null,
    "WithProtocolEndsMarker.StructContainingEnds",
    16,
    0
)
